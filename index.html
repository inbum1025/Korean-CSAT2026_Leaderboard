<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 CSAT Leaderboard - Comprehensive Assessment of Semantic Tasks</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='grad' x1='0%' y1='0%' x2='100%' y2='100%'><stop offset='0%' style='stop-color:%237c3aed;stop-opacity:1' /><stop offset='50%' style='stop-color:%23a855f7;stop-opacity:1' /><stop offset='100%' style='stop-color:%239333ea;stop-opacity:1' /></linearGradient></defs><rect width='100' height='100' fill='url(%23grad)' rx='20'/><text x='50' y='70' font-size='60' font-weight='bold' text-anchor='middle' fill='white' font-family='Arial'>C</text></svg>" type="image/svg+xml">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        .gradient-header {
            background: linear-gradient(135deg, #7c3aed 0%, #a855f7 50%, #9333ea 100%);
        }
        
        .gradient-filter {
            background: linear-gradient(to right, #faf5ff 0%, #f0f9ff 100%);
        }
        
        .chart-container {
            background: white;
        }
        
        .chart-container canvas {
            background: white !important;
        }
        
        /* λ°μ‘ν• λ””μμΈ */
        @media (max-width: 768px) {
            .container {
                padding-left: 1rem;
                padding-right: 1rem;
            }
            
            h1 {
                font-size: 1.75rem !important;
            }
            
            .gradient-filter {
                padding: 1rem !important;
            }
            
            .gradient-filter .grid {
                grid-template-columns: 1fr !important;
            }
        }
        
        @media (max-width: 640px) {
            #performanceContent,
            #fullTableContent {
                width: 100% !important;
            }
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
    <!-- Header -->
    <header class="gradient-header text-white py-8 shadow-lg relative">
        <div class="container mx-auto px-4">
            <div class="absolute top-4 right-4">
                <div class="flex gap-2">
                    <button id="langKo" onclick="setLanguage('ko')" class="px-4 py-2 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-lg font-medium transition-colors">ν•κµ­μ–΄</button>
                    <button id="langEn" onclick="setLanguage('en')" class="px-4 py-2 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-lg font-medium transition-colors">English</button>
                </div>
            </div>
            <h1 class="text-4xl font-bold mb-2" data-ko="2026ν•™λ…„λ„ ν•κµ­ λ€ν•™μν•™λ¥λ ¥μ‹ν—-μν•™ LLM ν‰κ°€ λ¦¬λ”λ³΄λ“" data-en="2026 Korean College Scholastic Ability Math-Test LLM Evaluation Leaderboard">2026ν•™λ…„λ„ ν•κµ­ λ€ν•™μν•™λ¥λ ¥μ‹ν— LLM ν‰κ°€ λ¦¬λ”λ³΄λ“</h1>
            <p class="text-xl text-purple-100 mb-1">2026 Korean CSAT-Math Leaderboard</p>
            <p class="text-sm text-purple-200 mt-2">ISoft Lab, Chungnam National University</p>
            <p class="text-sm text-purple-200 mt-2">
                <a href="https://isoft.cnu.ac.kr/" target="_blank" rel="noopener noreferrer" class="text-blue-300 hover:text-blue-200 underline">https://isoft.cnu.ac.kr/</a>
            </p>
        </div>
    </header>

    <!-- Paper Links Section -->
    <section class="bg-gradient-to-r from-blue-600 to-purple-600 text-white py-4 shadow-md">
        <div class="container mx-auto px-4">
            <div class="flex flex-col md:flex-row items-center justify-center gap-4 md:gap-6">
                <span class="text-sm md:text-base font-semibold" data-ko="π“„ λ…Όλ¬Έ:" data-en="π“„ Paper:">π“„ λ…Όλ¬Έ:</span>
                <a href="#" id="paperLinkEn" target="_blank" rel="noopener noreferrer" 
                   class="px-4 py-2 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-lg font-medium transition-colors text-sm md:text-base border border-white border-opacity-30"
                   data-ko="English Version" data-en="English Version">
                    English Version
                </a>
                <a href="#" id="paperLinkKo" target="_blank" rel="noopener noreferrer" 
                   class="px-4 py-2 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-lg font-medium transition-colors text-sm md:text-base border border-white border-opacity-30"
                   data-ko="ν•κµ­μ–΄ λ²„μ „" data-en="Korean Version">
                    ν•κµ­μ–΄ λ²„μ „
                </a>
            </div>
        </div>
    </section>

    <!-- Developer Upload Section (Hidden by default) -->
    <div id="uploadSection" class="hidden bg-gray-100 border-b border-gray-300 py-3">
        <div class="container mx-auto px-4">
            <div class="flex items-center gap-3">
                <span class="text-sm font-semibold text-gray-700">λ°μ΄ν„° νμΌ μ—…λ΅λ“ (κ°λ°μ λ¨λ“):</span>
                <input type="file" id="tsvFileInput" accept=".tsv" class="text-sm border border-gray-300 rounded px-3 py-1">
                <button onclick="loadTSVFile()" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-1 rounded text-sm font-medium">
                    TSV νμΌ λ΅λ“
                </button>
                <span id="fileStatus" class="text-sm text-purple-600 font-medium"></span>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="container mx-auto px-4 py-8 space-y-8">
        <!-- Experiment Introduction Section -->
        <section class="bg-white rounded-lg shadow-xl p-6 mb-8">
            <div class="prose max-w-none">
                <p class="text-gray-700 leading-relaxed mb-4"
                   data-ko="μ €ν¬ ν€μ€ 2025ν•™λ…„λ„ μλ¥ μν•™ μ‹ν—μ§€κ°€ κ³µμ‹ κ³µκ°λλ” μ¦‰μ‹, μ£Όμ” λ€κ·λ¨ μ–Έμ–΄λ¨λΈ(LLMs)μ—κ² λ™μΌν• μ‹ν—μ§€λ¥Ό ν’€μ΄ν•λ„λ΅ μ§„ν–‰ν•μ€μµλ‹λ‹¤. λ¨λ“  μ¶”λ΅  λ° μ‘λ‹µ μƒμ„±μ€ μ‹ν—μ§€ κ³µκ° ν›„ 2μ‹κ°„ μ΄λ‚΄μ— μ™„λ£λμ—μΌλ©°, μ΄λ΅ μΈν•΄ μ–΄λ–¤ λ¨λΈλ„ ν•΄λ‹Ή λ¬Έμ λ¥Ό μ‚¬μ „μ— ν•™μµν–μ„ κ°€λ¥μ„±μ€ λ§¤μ° λ‚®λ‹¤κ³  νλ‹¨λ©λ‹λ‹¤."
                   data-en="Our team immediately conducted evaluations by having major large language models (LLMs) solve the same test papers as soon as the 2025 CSAT mathematics test papers were officially released. All reasoning and response generation were completed within 2 hours after the test papers were released, making it highly unlikely that any model had pre-trained on these problems.">
                    μ €ν¬ ν€μ€ 2025ν•™λ…„λ„ μλ¥ μν•™ μ‹ν—μ§€κ°€ κ³µμ‹ κ³µκ°λλ” μ¦‰μ‹, μ£Όμ” λ€κ·λ¨ μ–Έμ–΄λ¨λΈ(LLMs)μ—κ² λ™μΌν• μ‹ν—μ§€λ¥Ό ν’€μ΄ν•λ„λ΅ μ§„ν–‰ν•μ€μµλ‹λ‹¤. λ¨λ“  μ¶”λ΅  λ° μ‘λ‹µ μƒμ„±μ€ μ‹ν—μ§€ κ³µκ° ν›„ 2μ‹κ°„ μ΄λ‚΄μ— μ™„λ£λμ—μΌλ©°, μ΄λ΅ μΈν•΄ μ–΄λ–¤ λ¨λΈλ„ ν•΄λ‹Ή λ¬Έμ λ¥Ό μ‚¬μ „μ— ν•™μµν–μ„ κ°€λ¥μ„±μ€ λ§¤μ° λ‚®λ‹¤κ³  νλ‹¨λ©λ‹λ‹¤.
                </p>
                <p class="text-gray-700 leading-relaxed"
                   data-ko="λ³Έ λ¦¬λ”λ³΄λ“λ” μ΄λ¬ν• ν‰κ°€ μ μ°¨λ¥Ό ν†µν•΄ μμ§‘λ κ²°κ³Όλ¥Ό κΈ°λ°μΌλ΅, κ° λ¨λΈμ μ‹¤μ  λ¬Έμ  ν•΄κ²° λ¥λ ¥κ³Ό μ–Έμ–΄Β·λ¨λ‹¬λ¦¬ν‹° μ΅°κ±΄μ— λ”°λ¥Έ μ„±λ¥ μ°¨μ΄λ¥Ό μ²΄κ³„μ μΌλ΅ ν‰κ°€ν•μ€μµλ‹λ‹¤."
                   data-en="This leaderboard systematically evaluated each model's actual problem-solving capabilities and performance differences according to language and modality conditions, based on the results collected through this evaluation process.">
                    λ³Έ λ¦¬λ”λ³΄λ“λ” μ΄λ¬ν• ν‰κ°€ μ μ°¨λ¥Ό ν†µν•΄ μμ§‘λ κ²°κ³Όλ¥Ό κΈ°λ°μΌλ΅, κ° λ¨λΈμ μ‹¤μ  λ¬Έμ  ν•΄κ²° λ¥λ ¥κ³Ό μ–Έμ–΄Β·λ¨λ‹¬λ¦¬ν‹° μ΅°κ±΄μ— λ”°λ¥Έ μ„±λ¥ μ°¨μ΄λ¥Ό μ²΄κ³„μ μΌλ΅ ν‰κ°€ν•μ€μµλ‹λ‹¤.
                </p>
            </div>
        </section>

        <!-- Experiment Description Section -->
        <section class="bg-white rounded-lg shadow-xl p-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4" data-ko="μ‹¤ν— κµ¬μ„±" data-en="Experiment Configuration">μ‹¤ν— κµ¬μ„±</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div class="bg-blue-50 border-l-4 border-blue-500 p-4">
                    <h3 class="font-semibold text-gray-800 mb-3" data-ko="λ¬Έν•­ κµ¬μ„±" data-en="Question Composition">λ¬Έν•­ κµ¬μ„±</h3>
                    <ul class="space-y-2 text-sm text-gray-700">
                        <li><strong data-ko="μ΄ λ¬Έν•­ μ:" data-en="Total Questions:">μ΄ λ¬Έν•­ μ:</strong> <span data-ko="30λ¬Έν•­" data-en="30 questions">30λ¬Έν•­</span></li>
                        <li><strong data-ko="κ³µν†µ κ³Όλ©:" data-en="Common Subject:">κ³µν†µ κ³Όλ©:</strong> <span data-ko="22λ¬Έν•­" data-en="22 questions">22λ¬Έν•­</span>
                            <ul class="ml-4 mt-1 space-y-1">
                                <li data-ko="μν•™β… : 11λ¬Έν•­" data-en="Mathematics I: 11 questions">μν•™β… : 11λ¬Έν•­ (μμƒ)</li>
                                <li data-ko="μν•™β…΅: 11λ¬Έν•­" data-en="Mathematics II: 11 questions">μν•™β…΅: 11λ¬Έν•­ (μμƒ)</li>
                            </ul>
                        </li>
                        <li><strong data-ko="μ„ νƒ κ³Όλ©:" data-en="Selective Subject:">μ„ νƒ κ³Όλ©:</strong> <span data-ko="8λ¬Έν•­" data-en="8 questions">8λ¬Έν•­</span>
                            <ul class="ml-4 mt-1">
                                <li data-ko="ν™•λ¥ κ³Ό ν†µκ³„, λ―Έμ λ¶„, κΈ°ν• μ¤‘ νƒ 1" data-en="One of: Probability & Statistics, Calculus, Geometry">ν™•λ¥ κ³Ό ν†µκ³„, λ―Έμ λ¶„, κΈ°ν• μ¤‘ νƒ 1</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <div class="bg-purple-50 border-l-4 border-purple-500 p-4">
                    <h3 class="font-semibold text-gray-800 mb-3" data-ko="λ¬Έν•­ μ ν•" data-en="Question Types">λ¬Έν•­ μ ν•</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-700">
                        <div>
                            <strong class="text-base" data-ko="1. κ³µν†µκ³Όλ© (1β€“22λ²)" data-en="1. Common Subject (1β€“22)">1. κ³µν†µκ³Όλ© (1β€“22λ²)</strong>
                            <ul class="mt-2 space-y-2">
                                <li>
                                    <strong data-ko="β‘  κ°κ΄€μ‹ 15λ¬Έν•­ (1β€“15λ²)" data-en="β‘  Multiple Choice: 15 questions (1β€“15)">β‘  κ°κ΄€μ‹ 15λ¬Έν•­ (1β€“15λ²)</strong>
                                    <ul class="ml-4 mt-1 space-y-1">
                                        <li data-ko="2μ : 2λ¬Έν•­" data-en="2 score: 2 questions">2μ : 2λ¬Έν•­</li>
                                        <li data-ko="3μ : 6λ¬Έν•­" data-en="3 score: 6 questions">3μ : 6λ¬Έν•­</li>
                                        <li data-ko="4μ : 7λ¬Έν•­" data-en="4 score: 7 questions">4μ : 7λ¬Έν•­</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong data-ko="β‘΅ λ‹¨λ‹µν• 7λ¬Έν•­ (16β€“22λ²)" data-en="β‘΅ Short Answer: 7 questions (16β€“22)">β‘΅ λ‹¨λ‹µν• 7λ¬Έν•­ (16β€“22λ²)</strong>
                                    <ul class="ml-4 mt-1">
                                        <li data-ko="μ „λ¶€ 4μ  λ¬Έν•­" data-en="All 4 score questions">μ „λ¶€ 4μ  λ¬Έν•­</li>
                                        <li data-ko="(μΌλ¶€λ” μ—°μ† 4μ  λ¬Έν•­ λΈ”λ΅ κµ¬μ„±, μ΄ 8μ )" data-en="(Some are consecutive 4-score question blocks, total 8 score)">(μΌλ¶€λ” μ—°μ† 4μ  λ¬Έν•­ λΈ”λ΅ κµ¬μ„±, μ΄ 8μ )</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div>
                            <strong class="text-base" data-ko="2. μ„ νƒκ³Όλ© (23β€“30λ²)" data-en="2. Selective Subject (23β€“30)">2. μ„ νƒκ³Όλ© (23β€“30λ²)</strong>
                            <ul class="mt-2 space-y-2">
                                <li>
                                    <strong data-ko="β‘  κ°κ΄€μ‹ 6λ¬Έν•­ (23β€“28λ²)" data-en="β‘  Multiple Choice: 6 questions (23β€“28)">β‘  κ°κ΄€μ‹ 6λ¬Έν•­ (23β€“28λ²)</strong>
                                    <ul class="ml-4 mt-1 space-y-1">
                                        <li data-ko="2μ : 1λ¬Έν•­ (23λ²)" data-en="2 score: 1 question (23)">2μ : 1λ¬Έν•­ (23λ²)</li>
                                        <li data-ko="3μ : 4λ¬Έν•­ (24β€“27λ²)" data-en="3 score: 4 questions (24β€“27)">3μ : 4λ¬Έν•­ (24β€“27λ²)</li>
                                        <li data-ko="4μ : 1λ¬Έν•­ (28λ²)" data-en="4 score: 1 question (28)">4μ : 1λ¬Έν•­ (28λ²)</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong data-ko="β‘΅ λ‹¨λ‹µν• 2λ¬Έν•­ (29β€“30λ²)" data-en="β‘΅ Short Answer: 2 questions (29β€“30)">β‘΅ λ‹¨λ‹µν• 2λ¬Έν•­ (29β€“30λ²)</strong>
                                    <ul class="ml-4 mt-1">
                                        <li data-ko="λ¨λ‘ 4μ  λ¬Έν•­" data-en="All 4 score questions">λ¨λ‘ 4μ  λ¬Έν•­</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Performance Description Section -->
        <section class="bg-white rounded-lg shadow-xl p-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4" data-ko="Performance μ„¤λ…" data-en="Performance Description">Performance μ„¤λ…</h2>
            <div class="mb-6">
                <h3 class="text-lg font-semibold text-gray-700 mb-3" data-ko="μν•™ μμ—­ μ μ κµ¬μ„±" data-en="Mathematics Section Score Composition">μν•™ μμ—­ μ μ κµ¬μ„±</h3>
                <div class="overflow-x-auto">
                    <table class="w-full border-collapse border border-gray-300">
                        <thead class="bg-purple-100">
                            <tr>
                                <th class="border border-gray-300 px-4 py-3 text-left font-semibold text-gray-700" data-ko="κµ¬λ¶„" data-en="Category">κµ¬λ¶„</th>
                                <th class="border border-gray-300 px-4 py-3 text-center font-semibold text-gray-700" data-ko="μ μ" data-en="Points">μ μ</th>
                                <th class="border border-gray-300 px-4 py-3 text-left font-semibold text-gray-700" data-ko="λΉ„κ³ " data-en="Note">λΉ„κ³ </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="border border-gray-300 px-4 py-3 font-medium" data-ko="κ³µν†µκ³Όλ©" data-en="Common Subject">κ³µν†µκ³Όλ©</td>
                                <td class="border border-gray-300 px-4 py-3 text-center" data-ko="74μ " data-en="74 points">74μ </td>
                                <td class="border border-gray-300 px-4 py-3" data-ko="μν•™ I, μν•™ II" data-en="Mathematics I, Mathematics II">μν•™ I, μν•™ II</td>
                            </tr>
                            <tr class="bg-gray-50">
                                <td class="border border-gray-300 px-4 py-3 font-medium" data-ko="μ„ νƒκ³Όλ©" data-en="Selective Subject">μ„ νƒκ³Όλ©</td>
                                <td class="border border-gray-300 px-4 py-3 text-center" data-ko="26μ " data-en="26 points">26μ </td>
                                <td class="border border-gray-300 px-4 py-3" data-ko="ν™•λ¥ κ³Ό ν†µκ³„, λ―Έμ λ¶„, κΈ°ν• μ¤‘ 1κ° μ„ νƒ" data-en="One of: Probability & Statistics, Calculus, Geometry">ν™•λ¥ κ³Ό ν†µκ³„, λ―Έμ λ¶„, κΈ°ν• μ¤‘ 1κ° μ„ νƒ</td>
                            </tr>
                            <tr class="bg-purple-50">
                                <td class="border border-gray-300 px-4 py-3 font-bold" data-ko="ν•©κ³„" data-en="Total">ν•©κ³„</td>
                                <td class="border border-gray-300 px-4 py-3 text-center font-bold" data-ko="152μ " data-en="152 points">152μ </td>
                                <td class="border border-gray-300 px-4 py-3" data-ko="κ³µν†µκ³Όλ©(74μ ) + μ„ νƒκ³Όλ©(26μ ) x 3  = 152μ " data-en="Common (74) + Selective (26) x 3 = 152">κ³µν†µκ³Όλ©(74μ ) + μ„ νƒκ³Όλ©(26μ ) = 152μ </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="bg-purple-50 border-l-4 border-purple-500 p-4">
                <p class="text-gray-700 leading-relaxed mb-3">
                    <strong data-ko="Performance κ³„μ‚°:" data-en="Performance Calculation:">Performance κ³„μ‚°:</strong>
                    <span data-ko="κ° λ¨λΈμ΄ μλ¥ μν•™ λ¬Έμ λ¥Ό ν’€μ—μ„ λ•, 152μ  λ§μ  μ¤‘ λ‡ μ μ„ λ§μ·„λ”μ§€λ¥Ό ν‘μ¤€ν™”ν•μ—¬ 100μ  λ§μ μΌλ΅ ν™μ‚°ν•μ—¬ ν‘μ‹ν•©λ‹λ‹¤."
                          data-en="Each model's performance is calculated by normalizing the score achieved out of 152 score to a 100-score scale when solving the CSAT mathematics problems.">
                        κ° λ¨λΈμ΄ μλ¥ μν•™ λ¬Έμ λ¥Ό ν’€μ—μ„ λ•, 152μ  λ§μ  μ¤‘ λ‡ μ μ„ λ§μ·„λ”μ§€λ¥Ό ν‘μ¤€ν™”ν•μ—¬ 100μ  λ§μ μΌλ΅ ν™μ‚°ν•μ—¬ ν‘μ‹ν•©λ‹λ‹¤.
                    </span>
                </p>
                <div class="mt-3 p-3 bg-white rounded border border-purple-200">
                    <p class="text-sm font-mono text-gray-800 text-center">
                        <span data-ko="Performance (ν™μ‚° μ μ) = (μ‹¤μ  μ μ / 152) Γ— 100" data-en="Performance (normalized score) = (Actual Points / 152) Γ— 100">Performance = (μ‹¤μ  μ μ / 152) Γ— 100</span>
                    </p>
                </div>
            </div>
        </section>

        <!-- Baseline Performance Section with Tabs -->
        <section class="bg-white rounded-lg shadow-xl p-6">
            <div class="mb-4">
                <div class="flex border-b border-gray-200 mb-4">
                    <button id="baselineTab" onclick="switchPerformanceTab('baseline')" 
                            class="px-6 py-3 font-semibold text-gray-700 border-b-2 border-purple-600 transition-colors">
                        <span data-ko="Baseline Performance" data-en="Baseline Performance">Baseline Performance</span>
                    </button>
                    <button id="bestTab" onclick="switchPerformanceTab('best')" 
                            class="px-6 py-3 font-semibold text-gray-500 hover:text-gray-700 transition-colors">
                        <span data-ko="Model Best Performance" data-en="Model Best Performance">Model Best Performance</span>
                    </button>
                </div>
            </div>
            
            <!-- Baseline Tab Content -->
            <div id="baselineTabContent">
                <div class="mb-4">
                    <p class="text-gray-600 mb-2">
                        <span class="font-semibold text-gray-500 underline decoration-gray-400" data-ko="Prompt Language:" data-en="Prompt Language:">Prompt Language:</span>
                        <span class="text-gray-800 font-medium" data-ko="Korean" data-en="Korean">Korean</span>
                        <span class="text-gray-400 mx-2">|</span>
                        <span class="font-semibold text-gray-500 underline decoration-gray-400" data-ko="Input Modality:" data-en="Input Modality:">Input Modality:</span>
                        <span class="text-gray-800 font-medium" data-ko="Text" data-en="Text">Text</span>
                    </p>
                    <p class="text-sm text-gray-500 italic" data-ko="λ¨λΈμ ν”„λ΅¬ν”„νΈ μ–Έμ–΄(Korean) λ° μ…λ ¥ λ¨λ‹¬λ¦¬ν‹°(Text)μ— λ”°λ¥Έ μ„±λ¥μ„ λ³΄μ—¬μ¤λ‹λ‹¤."
                       data-en="Shows model performance when tested with Korean prompt language and Text input modality.">
                        λ¨λΈμ ν”„λ΅¬ν”„νΈ μ–Έμ–΄(Korean) λ° μ…λ ¥ λ¨λ‹¬λ¦¬ν‹°(Text)μ— λ”°λ¥Έ μ„±λ¥μ„ λ³΄μ—¬μ¤λ‹λ‹¤.
                    </p>
                </div>
                <div id="baselineContent">
                    <div class="text-center py-12 text-gray-500" data-ko="λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘..." data-en="Loading data...">λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘...</div>
                </div>
            </div>
            
            <!-- Best Performance Tab Content -->
            <div id="bestTabContent" style="display: none;">
                <p class="text-gray-600 mb-4 text-sm" 
                   data-ko="κ° λ¨λΈμ μ…λ ¥ λ¨λ‹¬λ¦¬ν‹° λ° μ–Έμ–΄λ³„ μµκ³  μ„±λ¥μ„ λΉ„κµν•©λ‹λ‹¤." 
                   data-en="Compare the best performance of each model across different input modalities and languages.">
                    κ° λ¨λΈμ μ…λ ¥ λ¨λ‹¬λ¦¬ν‹° λ° μ–Έμ–΄λ³„ μµκ³  μ„±λ¥μ„ λΉ„κµν•©λ‹λ‹¤.
                </p>
                <div id="bestPerformanceContent">
                    <div class="text-center py-12 text-gray-500" data-ko="λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘..." data-en="Loading data...">λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘...</div>
                </div>
            </div>
        </section>

        <!-- Model Performance Chart Section -->
        <section class="bg-white rounded-lg shadow-xl p-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">Model Performance Chart</h2>

            <!-- Filter Panel -->
            <div class="gradient-filter rounded-lg p-5 border border-purple-200 mb-6">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2 flex items-center gap-2">
                            <span data-ko="Prompt Language" data-en="Prompt Language">Prompt Language</span>
                            <span class="relative group">
                                <svg class="w-4 h-4 text-gray-400 cursor-help" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/>
                                </svg>
                                <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-800 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap z-10" data-ko="ν”„λ΅¬ν”„νΈμ— μ‚¬μ©λ μ–Έμ–΄λ¥Ό μ„ νƒν•©λ‹λ‹¤" data-en="Select the language used in the prompt">ν”„λ΅¬ν”„νΈμ— μ‚¬μ©λ μ–Έμ–΄λ¥Ό μ„ νƒν•©λ‹λ‹¤</span>
                            </span>
                        </label>
                        <select id="languageFilter" class="w-full appearance-none bg-white border border-gray-300 rounded-lg px-4 py-2.5 pr-10 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all cursor-pointer">
                            <option value="Korean" selected>Korean</option>
                            <option value="English">English</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2 flex items-center gap-2">
                            <span data-ko="Input Modality" data-en="Input Modality">Input Modality</span>
                            <span class="relative group">
                                <svg class="w-4 h-4 text-gray-400 cursor-help" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/>
                                </svg>
                                <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-800 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap z-10" data-ko="μ…λ ¥ λ°μ΄ν„°μ ν•νƒλ¥Ό μ„ νƒν•©λ‹λ‹¤ (ν…μ¤νΈ, μ΄λ―Έμ§€, ν…μ¤νΈ+μ΄λ―Έμ§€)" data-en="Select the input data format (Text, Image, Text+Image)">μ…λ ¥ λ°μ΄ν„°μ ν•νƒλ¥Ό μ„ νƒν•©λ‹λ‹¤ (ν…μ¤νΈ, μ΄λ―Έμ§€, ν…μ¤νΈ+μ΄λ―Έμ§€)</span>
                            </span>
                        </label>
                        <select id="modalityFilter" class="w-full appearance-none bg-white border border-gray-300 rounded-lg px-4 py-2.5 pr-10 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all cursor-pointer">
                            <option value="Text">Text-only</option>
                            <option value="Image">Image-only</option>
                            <option value="Text+Image">Text+Figure</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2 flex items-center gap-2">
                            <span data-ko="Problem Category" data-en="Problem Category">Problem Category</span>
                            <span class="relative group">
                                <svg class="w-4 h-4 text-gray-400 cursor-help" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/>
                                </svg>
                                <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-800 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap z-10" data-ko="λ¬Έμ  μΉ΄ν…κ³ λ¦¬λ¥Ό μ„ νƒν•©λ‹λ‹¤" data-en="Select the problem category">λ¬Έμ  μΉ΄ν…κ³ λ¦¬λ¥Ό μ„ νƒν•©λ‹λ‹¤</span>
                            </span>
                        </label>
                        <select id="categoryFilter" class="w-full appearance-none bg-white border border-gray-300 rounded-lg px-4 py-2.5 pr-10 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all cursor-pointer" onchange="updateCategoryInfo()">
                            <option value="ALL" selected data-ko="μ „μ²΄ (30λ¬Έν•­, 152μ )" data-en="ALL (30 questions, 152 points)">ALL (30 questions, 152 points)</option>
                            <option value="κΈ°ν•" data-ko="κΈ°ν• (8λ¬Έν•­, 26μ )" data-en="Geometry (8 questions, 26 points)">Geometry (8 questions, 26 points)</option>
                            <option value="λ―Έμ λ¶„" data-ko="λ―Έμ λ¶„ (8λ¬Έν•­, 26μ )" data-en="Calculus (8 questions, 26 points)">Calculus (8 questions, 26 points)</option>
                            <option value="ν™•λ¥ κ³Όν†µκ³„" data-ko="ν™•λ¥ κ³Όν†µκ³„ (8λ¬Έν•­, 26μ )" data-en="Probability & Statistics (8 questions, 26 points)">Probability & Statistics (8 questions, 26 points)</option>
                            <option value="κ³µν†µκ³Όλ©" data-ko="κ³µν†µκ³Όλ© (22λ¬Έν•­, 74μ )" data-en="Common Subject (22 questions, 74 points)">Common Subject (22 questions, 74 points)</option>
                        </select>
                        <div id="categoryInfo" class="mt-2 text-xs text-gray-600" data-ko="30λ¬Έν•­, 152μ " data-en="30 questions, 152 points">30 questions, 152 points</div>
                    </div>
                </div>
            </div>

            <!-- Download Chart Button (Top) -->
            <div class="mb-4 flex justify-end">
                <button id="downloadPerformanceChartBtn" onclick="downloadChart('performanceChart', 'performance')"
                        class="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-colors shadow-md" style="display: none;">
                    <span class="text-sm font-medium">π“¥ Download Chart</span>
                </button>
            </div>

            <!-- Performance Chart and Table in 2 columns -->
            <div class="flex flex-col lg:flex-row gap-6">
                <!-- Performance Table (Left) - 35% -->
                <div class="lg:w-[35%]">
                    <h3 class="text-xl font-bold text-gray-800 mb-4" data-ko="Model Performance Table" data-en="Model Performance Table">Model Performance Table</h3>
                    <div id="fullTableContent">
                        <div class="text-center py-12 text-gray-500" data-ko="λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘..." data-en="Loading data...">λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘...</div>
                    </div>
                </div>

                <!-- Performance Chart (Right) - 65% -->
                <div id="performanceContent" class="lg:w-[65%]">
                    <div class="text-center py-12 text-gray-500" data-ko="λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘..." data-en="Loading data...">λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘...</div>
                </div>
            </div>
        </section>

        <!-- Latency & Performance Chart Section -->
        <section class="bg-white rounded-lg shadow-xl p-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-6" data-ko="Latency & Performance" data-en="Latency & Performance">Latency & Performance</h2>
            <p class="text-gray-600 mb-4 text-sm" 
               data-ko="κ° λ¨λΈμ μ‘λ‹µ μ‹κ°„(Latency)κ³Ό μ„±λ¥(Performance)μ„ λΉ„κµν•©λ‹λ‹¤. μ•„λ λ§‰λ€λ” μ‘λ‹µ μ‹κ°„(λ¶„), μ„ μ„ μ€ μ •κ·ν™”λ μ μλ¥Ό λ‚νƒ€λƒ…λ‹λ‹¤." 
               data-en="Compare response time (Latency) and performance for each model. The bottom bars show response time (minutes), and the top lines show normalized scores.">
                κ° λ¨λΈμ μ‘λ‹µ μ‹κ°„(Latency)κ³Ό μ„±λ¥(Performance)μ„ λΉ„κµν•©λ‹λ‹¤. μ•„λ λ§‰λ€λ” μ‘λ‹µ μ‹κ°„(λ¶„), μ„ μ„ μ€ μ •κ·ν™”λ μ μλ¥Ό λ‚νƒ€λƒ…λ‹λ‹¤.
            </p>
            <div id="latencyPerformanceContent">
                <div class="text-center py-12 text-gray-500" data-ko="λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘..." data-en="Loading data...">λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘...</div>
            </div>
        </section>

        <!-- GPT-5 Reasoning Analysis Section -->
        <section class="bg-white rounded-lg shadow-xl p-6" style="display: none !important; visibility: hidden !important;">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">GPT-5 Reasoning Analysis</h2>
            <div id="reasoningContent">
                <div class="text-center py-12 text-gray-500" data-ko="λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘..." data-en="Loading data...">λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘...</div>
            </div>
        </section>

        <!-- FAQ Section -->
        <section class="bg-white rounded-lg shadow-xl p-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-6" data-ko="μμ£Ό λ¬»λ” μ§λ¬Έ (FAQ)" data-en="Frequently Asked Questions (FAQ)">μμ£Ό λ¬»λ” μ§λ¬Έ (FAQ)</h2>
            
            <div class="space-y-6">
                <div class="bg-purple-50 border-l-4 border-purple-500 p-5 rounded-r-lg">
                    <h3 class="text-lg font-semibold text-gray-800 mb-3" data-ko="Q: μ…λ ¥μ΄ ν…μ¤νΈλ§ κ°€λ¥ν• λ¨λΈλ“¤μ€ μ–΄λ–»κ² ν‰κ°€ν–λ‚μ”?" data-en="Q: How were models that only support text input evaluated?">Q: μ…λ ¥μ΄ ν…μ¤νΈλ§ κ°€λ¥ν• λ¨λΈλ“¤μ€ μ–΄λ–»κ² ν‰κ°€ν–λ‚μ”?</h3>
                    <p class="text-gray-700 leading-relaxed" 
                       data-ko="A: ν…μ¤νΈλ§ μ…λ ¥μ΄ κ°€λ¥ν• λ¨λΈλ“¤μ€ image, text+figureμ—μ„ μ‹¤ν—μ„ ν•μ§€ μ•μ•λ‹¤. λ”°λΌμ„ textκ°€ μ…λ ¥λ¨λ‹¬λ¦¬ν‹°λ΅ λ“¤μ–΄κ°€λ”κ±΄ μ΄ 24κ°μ λ¨λΈ, λ‚λ¨Έμ§€λ” 14κ°μ λ¨λΈλ΅ μ‹¤ν—μ„ μν–‰ν•μ€λ‹¤." 
                       data-en="A: Models that only support text input were not tested with image or text+figure modalities. Therefore, experiments were conducted with 24 models for text input modality, and 14 models for other modalities.">
                        A: ν…μ¤νΈλ§ μ…λ ¥μ΄ κ°€λ¥ν• λ¨λΈλ“¤μ€ image, text+figureμ—μ„ μ‹¤ν—μ„ ν•μ§€ μ•μ•λ‹¤. λ”°λΌμ„ textκ°€ μ…λ ¥λ¨λ‹¬λ¦¬ν‹°λ΅ λ“¤μ–΄κ°€λ”κ±΄ μ΄ 24κ°μ λ¨λΈ, λ‚λ¨Έμ§€λ” 14κ°μ λ¨λΈλ΅ μ‹¤ν—μ„ μν–‰ν•μ€λ‹¤.
                    </p>
                </div>
                
                <div class="bg-purple-50 border-l-4 border-purple-500 p-5 rounded-r-lg">
                    <h3 class="text-lg font-semibold text-gray-800 mb-3" data-ko="Q: λ¨λΈμ μ…μ¶λ ¥ ν•νƒλ” μ–΄λ–»κ²λλ‚μ”?" data-en="Q: What is the input and output format of the models?">Q: λ¨λΈμ μ…μ¶λ ¥ ν•νƒλ” μ–΄λ–»κ²λλ‚μ”?</h3>
                    <p class="text-gray-700 leading-relaxed" 
                       data-ko="A: λ¨λΈμ μ…λ ¥μ κ²½μ° μλ¥ μν•™λ¬Έμ λ¥Ό Markdownκ³Ό LatexμΌλ΅ ν‘κΈ°ν•μ—¬ μΌκ΄€μ„±μκ² μ…λ ¥ν•΄μ£Όμ—λ‹¤. μ¶λ ¥ν•μ‹ μ—­μ‹ λ¨λ“  λ¨λΈλ™μΌν•κ² μ¶λ ¥ν•μ€μΌλ©°, μΌλ¶€ λ¨λΈμ€ λ¬Έμ ν’€μ΄ λ¥λ ¥κ³Ό λ³„κ°λ΅ μ¶λ ¥ν•μ‹μ„ κ³ λ ¤ν•μ§€μ•μ•„ μ„±λ¥μ΄ μ €ν•λλ” κ²½μ°λ„ μμ—λ‹¤. μμ„Έν• λ‚΄μ©μ€ λ³Έ μ‚¬μ΄νΈμ μƒλ‹¨μ— μ„μΉν• λ…Όλ¬Έμ— μ‘μ„±λμ–΄μλ‹¤." 
                       data-en="A: For model inputs, CSAT math problems were consistently formatted using Markdown and LaTeX notation. The output format was also standardized across all models. However, some models showed performance degradation due to not properly considering the output format, independent of their problem-solving capabilities. For more details, please refer to the paper located at the top of this site.">
                        A: λ¨λΈμ μ…λ ¥μ κ²½μ° μλ¥ μν•™λ¬Έμ λ¥Ό Markdownκ³Ό LatexμΌλ΅ ν‘κΈ°ν•μ—¬ μΌκ΄€μ„±μκ² μ…λ ¥ν•΄μ£Όμ—λ‹¤. μ¶λ ¥ν•μ‹ μ—­μ‹ λ¨λ“  λ¨λΈλ™μΌν•κ² μ¶λ ¥ν•μ€μΌλ©°, μΌλ¶€ λ¨λΈμ€ λ¬Έμ ν’€μ΄ λ¥λ ¥κ³Ό λ³„κ°λ΅ μ¶λ ¥ν•μ‹μ„ κ³ λ ¤ν•μ§€μ•μ•„ μ„±λ¥μ΄ μ €ν•λλ” κ²½μ°λ„ μμ—λ‹¤. μμ„Έν• λ‚΄μ©μ€ λ³Έ μ‚¬μ΄νΈμ μƒλ‹¨μ— μ„μΉν• λ…Όλ¬Έμ— μ‘μ„±λμ–΄μλ‹¤.
                    </p>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="bg-gray-800 text-gray-300 py-6 mt-12">
        <div class="container mx-auto px-4 text-center">
            <p>Β© 2025 ISoft Lab, Chungnam National University. All rights reserved.</p>
        </div>
    </footer>

    <script>
        let rawData = null;
        let parsedData = null;
        let categoryData = null; // λ¬Έμ  μΉ΄ν…κ³ λ¦¬λ³„ λ°μ΄ν„°
        let baselineChart = null;
        let performanceChart = null;
        let reasoningChart = null;
        let bestPerformanceChart = null; // λ¨λΈλ³„ best μ„±λ¥ μ°¨νΈ
        let latencyPerformanceChart = null; // Latency & Performance μ°¨νΈ
        let latencyData = null; // Latency λ°μ΄ν„°
        let currentLanguage = 'en'; // κΈ°λ³Έ μ–Έμ–΄λ” μμ–΄
        const BASELINE_TIME = 152; // μ‹ν— μ‹κ°„ (λ¶„)

        // κ°λ°μ λ¨λ“: URLμ— ?dev=true μ¶”κ°€ν•λ©΄ μ—…λ΅λ“ μ„Ήμ… ν‘μ‹
        if (window.location.search.includes('dev=true')) {
            document.getElementById('uploadSection').classList.remove('hidden');
        }

        // μ–Έμ–΄ μ „ν™ ν•¨μ
        function setLanguage(lang) {
            currentLanguage = lang;

            // λ²„νΌ μ¤νƒ€μΌ μ—…λ°μ΄νΈ
            if (lang === 'ko') {
                document.getElementById('langKo').classList.add('bg-white', 'bg-opacity-30');
                document.getElementById('langKo').classList.remove('bg-opacity-20');
                document.getElementById('langEn').classList.remove('bg-opacity-30');
                document.getElementById('langEn').classList.add('bg-opacity-20');
            } else {
                document.getElementById('langEn').classList.add('bg-white', 'bg-opacity-30');
                document.getElementById('langEn').classList.remove('bg-opacity-20');
                document.getElementById('langKo').classList.remove('bg-opacity-30');
                document.getElementById('langKo').classList.add('bg-opacity-20');
            }

            // λ¨λ“  data-ko, data-en μ†μ„±μ„ κ°€μ§„ μ”μ† μ—…λ°μ΄νΈ
            document.querySelectorAll('[data-ko][data-en]').forEach(element => {
                const text = element.getAttribute(`data-${lang}`);
                if (text) {
                    element.textContent = text;
                }
            });
            
            // μΉ΄ν…κ³ λ¦¬ μ •λ³΄ μ—…λ°μ΄νΈ
            updateCategoryInfo();
        }

        // μ μ λ‹¨μ„ λ°ν™ ν•¨μ
        function getScoreUnit() {
            return currentLanguage === 'ko' ? 'μ ' : ' score';
        }

        // μΉ΄ν…κ³ λ¦¬ μ •λ³΄ μ—…λ°μ΄νΈ
        function updateCategoryInfo() {
            const category = document.getElementById('categoryFilter')?.value || 'ALL';
            const infoDiv = document.getElementById('categoryInfo');
            if (!infoDiv) return;

            const categoryInfo = {
                'ALL': { ko: '30λ¬Έν•­, 152μ ', en: '30 questions, 152 points' },
                'κΈ°ν•': { ko: '8λ¬Έν•­, 26μ ', en: '8 questions, 26 points' },
                'λ―Έμ λ¶„': { ko: '8λ¬Έν•­, 26μ ', en: '8 questions, 26 points' },
                'ν™•λ¥ κ³Όν†µκ³„': { ko: '8λ¬Έν•­, 26μ ', en: '8 questions, 26 points' },
                'κ³µν†µκ³Όλ©': { ko: '22λ¬Έν•­, 74μ ', en: '22 questions, 74 points' }
            };

            const info = categoryInfo[category] || categoryInfo['ALL'];
            infoDiv.setAttribute('data-ko', info.ko);
            infoDiv.setAttribute('data-en', info.en);
            infoDiv.textContent = currentLanguage === 'ko' ? info.ko : info.en;
        }

        // νƒ­ μ „ν™ ν•¨μ
        function switchPerformanceTab(tab) {
            const baselineTab = document.getElementById('baselineTab');
            const bestTab = document.getElementById('bestTab');
            const baselineContent = document.getElementById('baselineTabContent');
            const bestContent = document.getElementById('bestTabContent');

            if (tab === 'baseline') {
                baselineTab.classList.add('border-b-2', 'border-purple-600', 'text-gray-700');
                baselineTab.classList.remove('text-gray-500');
                bestTab.classList.remove('border-b-2', 'border-purple-600', 'text-gray-700');
                bestTab.classList.add('text-gray-500');
                baselineContent.style.display = 'block';
                bestContent.style.display = 'none';
            } else {
                bestTab.classList.add('border-b-2', 'border-purple-600', 'text-gray-700');
                bestTab.classList.remove('text-gray-500');
                baselineTab.classList.remove('border-b-2', 'border-purple-600', 'text-gray-700');
                baselineTab.classList.add('text-gray-500');
                baselineContent.style.display = 'none';
                bestContent.style.display = 'block';
            }
        }


        // λ¨λΈ μ΄λ¦„ λ§¤ν•‘
        const modelNameMap = {
            'GPT-5 Codex': 'GPT-5 Codex',
            'GPT-5': 'GPT-5',
            'GPT-5-mini': 'GPT-5-mini',
            'GPT-5-nano': 'GPT-5-nano',
            'gpt-oss-20B': 'GPT-OSS-20B',
            'Grok 4': 'Grok 4',
            'Grok 4 Fast': 'Grok 4 Fast',
            'Qwen3 235B A22B': 'Qwen3 235B A22B',
            'Claude 4.5 Sonnet': 'Claude 4.5 Sonnet',
            'Claude 4.5 Haiku': 'Claude 4.5 Haiku',
            'Claude 4.1 Opus': 'Claude 4.1 Opus',
            'Gemini 2.5 Pro': 'Gemini 2.5 Pro',
            'Gemini 2.5 Flash': 'Gemini 2.5 Flash',
            'Deepseek R1 0528': 'Deepseek R1 0528',
            'Deepseek V3.2 Exp': 'Deepseek V3.2 Exp',
            'GLM 4.6': 'GLM 4.6',
            'Magistral Medium 2506': 'Magistral Medium 2506',
            'Magistral Medium 2506 (thinking)': 'Magistral Medium 2506 (thinking)',
            'MiniMax M2': 'MiniMax M2',
            'Llama 4 Maverick': 'Llama 4 Maverick',
            'Llama 3.3 Nemotron Super 49B V1.5': 'Llama 3.3 Nemotron Super 49B V1.5',
            'Kimi K2 0905': 'Kimi K2 0905',
            'Kimi K2 Thinking': 'Kimi K2 Thinking'
        };

        // λ¨λΈ μ•„μ΄μ½ λ§¤ν•‘ (μ μ΅°μ‚¬λ³„ λ§¤ν•‘, SVG μ°μ„  μ‚¬μ©)
        const modelIconMap = {
            // OpenAI κ³„μ—΄
            'GPT-5 Codex': 'model_icon/openai.svg',
            'GPT-5': 'model_icon/openai.svg',
            'GPT-5-mini': 'model_icon/openai.svg',
            'GPT-5-nano': 'model_icon/openai.svg',
            'gpt-oss-20B': 'model_icon/openai.svg',
            // X.AI κ³„μ—΄
            'Grok 4': 'model_icon/xai.svg',
            'Grok 4 Fast': 'model_icon/xai.svg',
            // Qwen κ³„μ—΄
            'Qwen3 235B A22B': 'model_icon/qwen.svg',
            'Qwen3 235B A22B Thinking 2507': 'model_icon/qwen.svg',
            // Anthropic (Claude) κ³„μ—΄ - antropic.svg μ°μ„  μ‚¬μ©
            'Claude 4.5 Sonnet': 'model_icon/antropic.svg',
            'Claude 4.5 Haiku': 'model_icon/antropic.svg',
            'Claude 4.1 Opus': 'model_icon/antropic.svg',
            // Google κ³„μ—΄ - google.svg μ‚¬μ©
            'Gemini 2.5 Pro': 'model_icon/google.svg',
            'Gemini 2.5 Flash': 'model_icon/google.svg',
            // Deepseek κ³„μ—΄
            'Deepseek R1 0528': 'model_icon/deepseek.svg',
            'Deepseek V3.2 Exp': 'model_icon/deepseek.svg',
            // ZAI (GLM) κ³„μ—΄
            'GLM 4.6': 'model_icon/zai.svg',
            // Mistral κ³„μ—΄ - PNGλ§ μμ
            'Magistral Medium 2506': 'model_icon/mistral.png',
            'Magistral Medium 2506 (thinking)': 'model_icon/mistral.png',
            // MiniMax κ³„μ—΄
            'MiniMax M2': 'model_icon/minimax.svg',
            // Meta (Llama) κ³„μ—΄
            'Llama 4 Maverick': 'model_icon/meta.svg',
            // NVIDIA κ³„μ—΄
            'Llama 3.3 Nemotron Super 49B V1.5': 'model_icon/nvidia.svg',
            // Moonshot (Kimi) κ³„μ—΄
            'Kimi K2 0905': 'model_icon/moonshot.svg',
            'Kimi K2 Thinking': 'model_icon/moonshot.svg'
        };

        // Open-Weight Modelsμ™€ Closed-Weight Models λ¶„λ¥
        const openWeightModels = [
            'gpt-oss-20B',
            'Qwen3 235B A22B',
            'Qwen3 235B A22B Thinking 2507',
            'Deepseek R1 0528',
            'Deepseek V3.2 Exp',
            'GLM 4.6',
            'Magistral Medium 2506',
            'Magistral Medium 2506 (thinking)',
            'Llama 4 Maverick',
            'Llama 3.3 Nemotron Super 49B V1.5'
        ];

        const closedWeightModels = [
            'GPT-5 Codex',
            'GPT-5',
            'GPT-5-mini',
            'GPT-5-nano',
            'Grok 4',
            'Grok 4 Fast',
            'Claude 4.5 Sonnet',
            'Claude 4.5 Haiku',
            'Claude 4.1 Opus',
            'Gemini 2.5 Pro',
            'Gemini 2.5 Flash',
            'MiniMax M2',
            'Kimi K2 0905',
            'Kimi K2 Thinking'
        ];

	const closedWeightModelSet = new Set(closedWeightModels);

        // μ•„μ΄μ½ μ΄λ―Έμ§€ μΊμ‹
        const iconImageCache = {};

        // ISoft λ΅κ³  μ΄λ―Έμ§€ μΊμ‹
        let isoftLogoImage = null;

        // ISoft λ΅κ³  μ΄λ―Έμ§€ λ―Έλ¦¬ λ΅λ“
        function preloadIsoftLogo() {
            if (!isoftLogoImage) {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    isoftLogoImage = img;
                };
                img.onerror = () => {
                    console.warn('Failed to load ISoft logo');
                };
                img.src = 'isoft_logo.png';
            }
        }

        // μ•„μ΄μ½ μ΄λ―Έμ§€ λ―Έλ¦¬ λ΅λ“
        function preloadIcons() {
            const uniqueIcons = new Set(Object.values(modelIconMap).filter(Boolean));
            uniqueIcons.forEach(iconPath => {
                if (!iconImageCache[iconPath]) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        iconImageCache[iconPath] = img;
                    };
                    img.onerror = () => {
                        // λ΅λ“ μ‹¤ν¨ μ‹ λ¬΄μ‹
                    };
                    img.src = iconPath;
                }
            });
        }

        // μ΄κΈ° μ•„μ΄μ½ λ° λ΅κ³  λ΅λ“
        if (typeof window !== 'undefined') {
            window.addEventListener('load', () => {
                preloadIcons();
                preloadIsoftLogo();
            });
        }

        // TSV νμΌ νμ‹±
        function parseTSV(tsvText) {
            const lines = tsvText.split('\n').filter(line => line.trim());
            if (lines.length < 4) {
                throw new Error('Invalid TSV format');
            }

            const timeLimit = lines[0].split('\t').slice(1);
            const language = lines[1].split('\t').slice(1);
            const modality = lines[2].split('\t').slice(1);

            const columnMap = [];
            for (let i = 0; i < timeLimit.length; i++) {
                // Time limitμ΄ XμΈ κ²ƒλ§ μ‚¬μ© (Cognitive Load μ—†μ)
                if (timeLimit[i] === 'X') {
                    columnMap.push({
                        language: language[i],
                        modality: modality[i],
                        index: i
                    });
                }
            }

            const models = [];
            const reasoningRows = [];

            for (let i = 4; i < lines.length; i++) {
                const parts = lines[i].split('\t');
                const modelName = parts[0].trim();

                if (!modelName) continue;

                if (modelName.includes('GPT-5 reasoning effort')) {
                    // Time limitμ΄ XμΈ κ²ƒλ§ μ‚¬μ© (μ²μ 6κ° μ»¬λΌ)
                    const timeLimit = lines[0].split('\t').slice(1);
                    const language = lines[1].split('\t').slice(1);
                    const modality = lines[2].split('\t').slice(1);

                    const reasoningData = [];
                    for (let i = 0; i < timeLimit.length; i++) {
                        if (timeLimit[i] === 'X') {
                            const cleaned = parts[i + 1] ? parts[i + 1].trim().replace('%', '') : '';
                            reasoningData.push({
                                language: language[i],
                                modality: modality[i],
                                value: cleaned === '' ? null : parseFloat(cleaned)
                            });
                        }
                    }

                    reasoningRows.push({
                        name: modelName,
                        data: reasoningData
                    });
                } else {
                    const scores = parts.slice(1).map((val, idx) => {
                        const cleaned = val.trim().replace('%', '');
                        if (cleaned === '' || cleaned === 'X') return null;
                        return {
                            value: parseFloat(cleaned),
                            column: columnMap[idx]
                        };
                    });

                    // λ¨λ“  μ μκ°€ nullμΈ λ¨λΈμ€ μ μ™Έ (μ„±λ¥ λ°μ΄ν„°κ°€ μ „ν€ μ—†λ” λ¨λΈ)
                    const hasAnyScore = scores.some(score => score !== null);
                    if (hasAnyScore) {
                        models.push({
                            name: modelName,
                            scores: scores
                        });
                    }
                }
            }

            return { models, columnMap, reasoningRows };
        }

        // Latency TSV νμΌ νμ‹±
        function parseLatencyTSV(tsvText) {
            const lines = tsvText.split('\n').filter(line => line.trim());
            if (lines.length < 4) {
                throw new Error('Invalid Latency TSV format');
            }

            const timeLimit = lines[0].split('\t').slice(1);
            const language = lines[1].split('\t').slice(1);
            const modality = lines[2].split('\t').slice(1);

            const columnMap = [];
            for (let i = 0; i < timeLimit.length; i++) {
                // Time limitμ΄ XμΈ κ²ƒλ§ μ‚¬μ© (Cognitive Load μ—†μ)
                if (timeLimit[i] === 'X') {
                    columnMap.push({
                        language: language[i],
                        modality: modality[i],
                        index: i
                    });
                }
            }

            const latencyMap = {}; // {modelName: {columnIndex: latency}}

            for (let i = 4; i < lines.length; i++) {
                const parts = lines[i].split('\t');
                const modelName = parts[0].trim();
                
                if (!modelName || modelName.includes('reasoning')) continue;

                const latencies = parts.slice(1).map((val, idx) => {
                    const cleaned = val.trim();
                    if (cleaned === '' || cleaned === 'X') return null;
                    return {
                        value: parseFloat(cleaned) / 60.0, // μ΄λ¥Ό λ¶„μΌλ΅ λ³€ν™
                        column: columnMap[idx]
                    };
                });

                if (!latencyMap[modelName]) {
                    latencyMap[modelName] = {};
                }

                latencies.forEach((latency, idx) => {
                    if (latency && latency.column) {
                        const key = `${latency.column.language}_${latency.column.modality}`;
                        latencyMap[modelName][key] = latency.value;
                    }
                });
            }

            return latencyMap;
        }

        // λ¬Έμ  μΉ΄ν…κ³ λ¦¬λ³„ TSV νμΌ νμ‹±
        function parseCategoryTSV(tsvText) {
            const lines = tsvText.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                throw new Error('Invalid category TSV format');
            }

            const headers = lines[0].split('\t');
            const modelIndex = headers.indexOf('model_id');
            const timeLimitIndex = headers.indexOf('time_limit');
            const languageIndex = headers.indexOf('language');
            const contentModeIndex = headers.indexOf('content_mode');
            const groupValueIndex = headers.indexOf('group_value');
            const scoreIndex = headers.indexOf('score');

            const categoryMap = {}; // {modelName: {language: {modality: {category: score}}}}

            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split('\t');
                if (parts.length < Math.max(modelIndex, timeLimitIndex, languageIndex, contentModeIndex, groupValueIndex, scoreIndex) + 1) {
                    continue;
                }

                const timeLimit = parts[timeLimitIndex]?.trim();
                if (timeLimit !== 'off') continue; // time_limitμ΄ 'off'μΈ κ²ƒλ§ μ‚¬μ©

                const modelId = parts[modelIndex]?.trim();
                if (!modelId) continue;

                // model_idμ—μ„ λ¨λΈ μ΄λ¦„ μ¶”μ¶ (μ: "openai/gpt-5-codex" -> "GPT-5 Codex")
                const modelName = extractModelName(modelId);
                if (!modelName) {
                    if (i < 10) console.warn('λ¨λΈ μ΄λ¦„ μ¶”μ¶ μ‹¤ν¨:', modelId);
                    continue;
                }

                const language = parts[languageIndex]?.trim();
                const contentMode = parts[contentModeIndex]?.trim();
                const groupValue = parts[groupValueIndex]?.trim();
                const scoreStr = parts[scoreIndex]?.trim();

                if (!language || !contentMode || !groupValue || !scoreStr) continue;

                // language λ³€ν™ (en -> English, ko -> Korean)
                const lang = language === 'en' ? 'English' : language === 'ko' ? 'Korean' : language;
                
                // content_mode λ³€ν™ (text_only -> Text, image_only -> Image, text_fig -> Text+Image)
                const modality = contentMode === 'text_only' ? 'Text' : 
                                contentMode === 'image_only' ? 'Image' : 
                                contentMode === 'text_fig' ? 'Text+Image' : contentMode;

                const score = parseFloat(scoreStr);
                if (isNaN(score)) continue;

                if (!categoryMap[modelName]) {
                    categoryMap[modelName] = {};
                }
                if (!categoryMap[modelName][lang]) {
                    categoryMap[modelName][lang] = {};
                }
                if (!categoryMap[modelName][lang][modality]) {
                    categoryMap[modelName][lang][modality] = {};
                }

                categoryMap[modelName][lang][modality][groupValue] = score;
            }

            console.log('parseCategoryTSV μ™„λ£:', Object.keys(categoryMap).length, 'models');
            if (Object.keys(categoryMap).length > 0) {
                const firstModel = Object.keys(categoryMap)[0];
                console.log('μ²« λ²μ§Έ λ¨λΈ μƒν”:', firstModel, categoryMap[firstModel]);
            }

            return categoryMap;
        }

        // model_idμ—μ„ λ¨λΈ μ΄λ¦„ μ¶”μ¶
        function extractModelName(modelId) {
            if (!modelId) return null;
            
            // model_idλ¥Ό λ¨λΈ μ΄λ¦„μΌλ΅ λ§¤ν•‘ (μ‹¤μ  λ°μ΄ν„° ν•μ‹μ— λ§μ¶¤)
            const modelIdMap = {
                'openai/gpt-5-codex': 'GPT-5 Codex',
                'openai/gpt-5': 'GPT-5',
                'openai/gpt-5-mini': 'GPT-5-mini',
                'openai/gpt-5-nano': 'GPT-5-nano',
                'openai/gpt-oss-20b': 'gpt-oss-20B',
                'x-ai/grok-4': 'Grok 4',
                'x-ai/grok-4-fast': 'Grok 4 Fast',
                'xai/grok-4': 'Grok 4', // νΈν™μ„±
                'xai/grok-4-fast': 'Grok 4 Fast', // νΈν™μ„±
                'qwen/qwen3-vl-235b-a22b-instruct': 'Qwen3 235B A22B',
                'qwen/qwen3-235b-a22b': 'Qwen3 235B A22B', // νΈν™μ„±
                'qwen/qwen3-vl-235b-a22b-thinking': 'Qwen3 235B A22B Thinking 2507',
                'anthropic/claude-sonnet-4.5': 'Claude 4.5 Sonnet',
                'anthropic/claude-4.5-sonnet': 'Claude 4.5 Sonnet', // νΈν™μ„±
                'anthropic/claude-haiku-4.5': 'Claude 4.5 Haiku',
                'anthropic/claude-4.5-haiku': 'Claude 4.5 Haiku', // νΈν™μ„±
                'anthropic/claude-opus-4.1': 'Claude 4.1 Opus',
                'anthropic/claude-4.1-opus': 'Claude 4.1 Opus', // νΈν™μ„±
                'google/gemini-2.5-pro': 'Gemini 2.5 Pro',
                'google/gemini-2.5-flash': 'Gemini 2.5 Flash',
                'deepseek/deepseek-r1-0528': 'Deepseek R1 0528',
                'deepseek/deepseek-v3.2-exp': 'Deepseek V3.2 Exp',
                'z-ai/glm-4.6': 'GLM 4.6',
                'zai/glm-4.6': 'GLM 4.6', // νΈν™μ„±
                'mistralai/magistral-medium-2506': 'Magistral Medium 2506',
                'mistral/magistral-medium-2506': 'Magistral Medium 2506', // νΈν™μ„±
                'mistralai/magistral-medium-2506:thinking': 'Magistral Medium 2506 (thinking)',
                'minimax/minimax-m2': 'MiniMax M2',
                'meta-llama/llama-4-maverick': 'Llama 4 Maverick',
                'meta/llama-4-maverick': 'Llama 4 Maverick', // νΈν™μ„±
                'nvidia/llama-3.3-nemotron-super-49b-v1.5': 'Llama 3.3 Nemotron Super 49B V1.5',
                'moonshotai/kimi-k2-0905': 'Kimi K2 0905',
                'moonshot/kimi-k2-0905': 'Kimi K2 0905', // νΈν™μ„±
                'moonshotai/kimi-k2-thinking': 'Kimi K2 Thinking',
                'moonshot/kimi-k2-thinking': 'Kimi K2 Thinking' // νΈν™μ„±
            };

            // μ •ν™•ν• λ§¤μΉ­ μ‹λ„
            if (modelIdMap[modelId]) {
                return modelIdMap[modelId];
            }

            // λ¶€λ¶„ λ§¤μΉ­ μ‹λ„ (reasoning effort λ“±μ΄ ν¬ν•¨λ κ²½μ°)
            const normalizedId = modelId.toLowerCase();
            for (const [id, name] of Object.entries(modelIdMap)) {
                const normalizedMapId = id.toLowerCase();
                // μ •ν™•ν μΌμΉν•κ±°λ‚, modelIdκ°€ mapIdλ΅ μ‹μ‘ν•λ” κ²½μ°
                if (normalizedId === normalizedMapId || normalizedId.startsWith(normalizedMapId + '/') || normalizedId.startsWith(normalizedMapId + '_')) {
                    return name;
                }
            }
            
            // μ¶”κ°€ ν¨ν„΄ λ§¤μΉ­: anthropic/claude-opus-4.1 κ°™μ€ ν•μ‹
            const claudeMatch = normalizedId.match(/anthropic\/claude-(sonnet|haiku|opus)-(\d+\.\d+)/);
            if (claudeMatch) {
                const variant = claudeMatch[1];
                const version = claudeMatch[2];
                const variantName = variant === 'sonnet' ? 'Sonnet' : variant === 'haiku' ? 'Haiku' : 'Opus';
                return `Claude ${version} ${variantName}`;
            }

            // λ§¤ν•‘λμ§€ μ•μ€ κ²½μ° μ›λ³Έμ—μ„ μ¶”μ¶ μ‹λ„
            const parts = modelId.split('/');
            if (parts.length > 1) {
                const modelPart = parts[1].split('-').slice(0, 3).join('-'); // μ²μ 3κ° λ¶€λ¶„λ§ μ‚¬μ©
                return modelPart.split('-').map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(' ');
            }
            return modelId;
        }

        // ν•„ν„°μ— λ§λ” μ»¬λΌ μΈλ±μ¤ μ°ΎκΈ°
        function findColumnIndex(columnMap, language, modality) {
            if (!columnMap || columnMap.length === 0) {
                console.warn('columnMapμ΄ λΉ„μ–΄μμµλ‹λ‹¤.');
                return -1;
            }
            
            const index = columnMap.findIndex(col =>
                col.language === language &&
                col.modality === modality
            );
            
            if (index === -1) {
                console.warn('μ»¬λΌμ„ μ°Ύμ„ μ μ—†μµλ‹λ‹¤:', { language, modality, availableColumns: columnMap.map(c => ({ lang: c.language, mod: c.modality })).slice(0, 5) });
            }
            
            return index;
        }

        // λ¬Έμ  μΉ΄ν…κ³ λ¦¬λ³„ λ§μ 
        const categoryMaxScores = {
            'κΈ°ν•': 26,
            'λ―Έμ λ¶„': 26,
            'ν™•λ¥ κ³Όν†µκ³„': 26,
            'μν•™1': 36,
            'μν•™2': 38,
            'κ³µν†µκ³Όλ©': 74, // μν•™1 + μν•™2
            'ALL': 152
        };

        // ν•„ν„°λ λ°μ΄ν„° κ°€μ Έμ¤κΈ°
        function getFilteredData(language, modality, category = 'ALL') {
            const categoryFilter = document.getElementById('categoryFilter')?.value || 'ALL';
            const actualCategory = category || categoryFilter;

            console.log('getFilteredData νΈμ¶:', { language, modality, category: actualCategory, hasParsedData: !!parsedData, hasCategoryData: !!categoryData });

            // λ¬Έμ  μΉ΄ν…κ³ λ¦¬ ν•„ν„°κ°€ μ μ©λ κ²½μ°
            if (actualCategory !== 'ALL' && categoryData) {
                const result = getCategoryFilteredData(language, modality, actualCategory);
                console.log('μΉ΄ν…κ³ λ¦¬ ν•„ν„° κ²°κ³Ό:', result?.length, 'models');
                return result;
            }

            // κΈ°μ΅΄ λ΅μ§ (ALLμΈ κ²½μ°)
            if (!parsedData) {
                console.warn('parsedDataκ°€ μ—†μµλ‹λ‹¤.');
                return null;
            }

            const columnIndex = findColumnIndex(parsedData.columnMap, language, modality);
            console.log('μ»¬λΌ μΈλ±μ¤:', columnIndex, 'for', language, modality);
            if (columnIndex === -1) {
                console.warn('μ»¬λΌμ„ μ°Ύμ„ μ μ—†μµλ‹λ‹¤:', language, modality);
                return null;
            }

            // μ΄λ―Έμ§€ λ―Έμ§€μ›μ΄ μ•„λ‹ κ²½μ° null μ μ μ μ™Έ
            const isImageModality = modality === 'Image' || modality === 'Text+Image';

            const filtered = parsedData.models
                .map(model => {
                    const score = model.scores[columnIndex];
                    const normalizedScore = score ? score.value : null;
                    // μ •κ·ν™” μ μμ—μ„ μ›μ μ μ—­μ‚° (μ •ν™•ν• κ³„μ‚° ν›„ μ •μλ΅ λ°μ¬λ¦Ό)
                    const rawScore = normalizedScore ? Math.round((normalizedScore / 100) * 152) : null;
                    return {
                        name: model.name,
                        score: normalizedScore,
                        rawScore: rawScore,
                        displayName: modelNameMap[model.name] || model.name
                    };
                })
                .filter(model => {
                    // λ¨λΈ μ΄λ¦„μ΄ μμ–΄μ•Ό ν•¨
                    if (!model.name || model.name.trim() === '') return false;
                    // μ΄λ―Έμ§€ λ¨λ‹¬λ¦¬ν‹°κ°€ μ•„λ‹ κ²½μ°, null μ μλ” μ μ™Έ (λ°μ΄ν„°κ°€ μ—†λ” λ¨λΈ)
                    if (!isImageModality && model.score === null) return false;
                    return true;
                })
                .sort((a, b) => {
                    if (a.score === null && b.score === null) return 0;
                    if (a.score === null) return 1;
                    if (b.score === null) return -1;
                    return b.score - a.score;
                })
                .map((item, index) => ({
                    ...item,
                    rank: index + 1
                }));

            console.log('ν•„ν„°λ λ°μ΄ν„°:', filtered.length, 'models');
            return filtered;
        }

        // λ¬Έμ  μΉ΄ν…κ³ λ¦¬λ³„ ν•„ν„°λ λ°μ΄ν„° κ°€μ Έμ¤κΈ°
        function getCategoryFilteredData(language, modality, category) {
            if (!categoryData || !parsedData) {
                console.warn('categoryData λλ” parsedDataκ°€ μ—†μµλ‹λ‹¤.');
                return null;
            }

            console.log('getCategoryFilteredData:', { language, modality, category, categoryDataKeys: Object.keys(categoryData).slice(0, 5) });

            const maxScore = categoryMaxScores[category] || 152;
            const models = [];

            // parsedDataμ λ¨λ“  λ¨λΈμ„ μνν•λ©΄μ„ categoryDataμ—μ„ μ°ΎκΈ°
            // categoryDataμ ν‚¤μ™€ parsedDataμ λ¨λΈ μ΄λ¦„μ΄ λ‹¤λ¥Ό μ μμΌλ―€λ΅ λ§¤μΉ­ ν•„μ”
            parsedData.models.forEach(parsedModel => {
                const parsedModelName = parsedModel.name;
                
                // categoryDataμ—μ„ λ¨λΈ μ°ΎκΈ° (μ •ν™•ν• λ§¤μΉ­ λλ” μ μ‚¬ν• μ΄λ¦„ μ°ΎκΈ°)
                let categoryModelName = null;
                for (const catModelName in categoryData) {
                    // μ •ν™•ν• λ§¤μΉ­
                    if (catModelName === parsedModelName) {
                        categoryModelName = catModelName;
                        break;
                    }
                    // displayNameμΌλ΅ λ§¤μΉ­
                    const catDisplayName = modelNameMap[catModelName] || catModelName;
                    const parsedDisplayName = modelNameMap[parsedModelName] || parsedModelName;
                    if (catDisplayName === parsedDisplayName) {
                        categoryModelName = catModelName;
                        break;
                    }
                }
                
                if (!categoryModelName) {
                    // λ§¤μΉ­λμ§€ μ•μ€ λ¨λΈμ€ κ±΄λ„λ›°κΈ°
                    return;
                }

                const langData = categoryData[categoryModelName][language];
                if (!langData) return;

                const modalityData = langData[modality];
                if (!modalityData) return;

                let rawScore = null;
                let normalizedScore = null;

                // categoryκ°€ 'κ³µν†µκ³Όλ©'μΈ κ²½μ° μν•™1κ³Ό μν•™2λ¥Ό ν•©μ‚°
                if (category === 'κ³µν†µκ³Όλ©') {
                    const math1Score = modalityData['μν•™1'] || 0;
                    const math2Score = modalityData['μν•™2'] || 0;
                    rawScore = Math.round(math1Score + math2Score); // μ‹¤μ  μ μλ” μ •μ
                    normalizedScore = rawScore ? (rawScore / maxScore) * 100 : null;
                } else {
                    rawScore = modalityData[category] !== null && modalityData[category] !== undefined ? Math.round(modalityData[category]) : null;
                    normalizedScore = rawScore ? (rawScore / maxScore) * 100 : null;
                }

                if (normalizedScore !== null) {
                    models.push({
                        name: parsedModelName, // parsedDataμ μ›λ³Έ λ¨λΈ μ΄λ¦„ μ‚¬μ©
                        score: normalizedScore,
                        rawScore: rawScore,
                        displayName: modelNameMap[parsedModelName] || parsedModelName
                    });
                }
            });

            const result = models
                .filter(model => model.score !== null)
                .sort((a, b) => b.score - a.score)
                .map((item, index) => ({
                    ...item,
                    rank: index + 1
                }));
            
            console.log('μΉ΄ν…κ³ λ¦¬ ν•„ν„° κ²°κ³Ό:', result.length, 'models', result.slice(0, 3));
            return result;
        }

        // μ„±λ¥ μ μμ— λ”°λ¥Έ μƒ‰μƒ
        function getBarColor(score) {
            if (score === null) return 'rgba(156, 163, 175, 0.6)';
            if (score >= 90) return 'rgba(34, 197, 94, 0.8)';
            if (score >= 70) return 'rgba(234, 179, 8, 0.8)';
            return 'rgba(239, 68, 68, 0.8)';
        }

        function getBorderColor(score) {
            if (score === null) return 'rgba(156, 163, 175, 0.8)';
            if (score >= 90) return 'rgba(34, 197, 94, 1)';
            if (score >= 70) return 'rgba(234, 179, 8, 1)';
            return 'rgba(239, 68, 68, 1)';
        }

        // κ°€λ΅ λ§‰λ€ μ°¨νΈ λ λ”λ§
        function renderHorizontalBarChart(data, containerId, title) {
            if (!data || data.length === 0) return;

            const ctx = document.getElementById(containerId);
            if (!ctx) return;

            // κΈ°μ΅΄ μ°¨νΈ μ κ±°
            if (containerId === 'baselineChart' && baselineChart) {
                baselineChart.destroy();
            }
            if (containerId === 'performanceChart' && performanceChart) {
                performanceChart.destroy();
            }
            if (containerId === 'bestPerformanceChart' && bestPerformanceChart) {
                bestPerformanceChart.destroy();
            }

            // null μ μ μ μ™Έ (μ΄λ―Έμ§€ λ―Έμ§€μ›μ΄ μ•„λ‹ κ²½μ°)
            const filteredData = data.filter(m => m.score !== null);

            const labels = filteredData.map(m => m.displayName || m.name);
            const scores = filteredData.map(m => m.score);

            // λ¨λΈ μ•„μ΄μ½ μ •λ³΄ μ €μ¥
            const modelIcons = filteredData.map(m => {
                const modelName = m.name;
                return modelIconMap[modelName] || null;
            });

            // μ΄λ―Έμ§€ λ―Έμ§€μ› λ¨λΈ ν™•μΈ (μ›λ³Έ λ°μ΄ν„°μ—μ„ ν™•μΈ)
            const hasImageModality = data.some(m => m.score === null);
            const imageNotSupported = hasImageModality && (containerId === 'performanceChart' || containerId === 'baselineChart');

            // μ•„μ΄μ½ λ°μ΄ν„°λ¥Ό μ°¨νΈμ— μ €μ¥ν•κΈ° μ„ν• λ³€μ
            const chartIconData = {
                filteredData: filteredData,
                modelIcons: modelIcons
            };

            const chartConfig = {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Performance (normalized score)',
                        data: scores,
                        backgroundColor: scores.map(score => getBarColor(score)),
                        borderColor: scores.map(score => getBorderColor(score)),
                        borderWidth: 2,
                        borderRadius: 6
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    backgroundColor: '#ffffff',
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.85)',
                            padding: 12,
                            titleFont: {
                                size: 14,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 13
                            },
                            callbacks: {
                                label: (context) => {
                                    const score = scores[context.dataIndex];
                                    const rawScore = filteredData[context.dataIndex]?.rawScore;
                                    if (score === null) {
                                        return 'Score: N/A (μ΄λ―Έμ§€ λ―Έμ§€μ›)';
                                    }
                                    if (rawScore !== null && rawScore !== undefined) {
                                        return [
                                            `Normalized: ${score.toFixed(1)}${getScoreUnit()}`,
                                            `Raw Score: ${Math.round(rawScore)}${currentLanguage === 'ko' ? 'μ ' : ' points'}`
                                        ];
                                    }
                                    return `Score: ${score.toFixed(1)}${getScoreUnit()}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                stepSize: 10,
                                callback: (value) => `${value}`,
                                font: {
                                    size: 11
                                },
                                color: '#6b7280'
                            },
                            grid: {
                                color: 'rgba(156, 163, 175, 0.2)'
                            },
                            title: {
                                display: true,
                                text: containerId === 'baselineChart' ? 'Performance (normalized score)' : 'Performance (normalized score)',
                                font: {
                                    size: 12,
                                    weight: '600'
                                },
                                color: '#374151'
                            }
                        },
			y: {
			    ticks: {
				display: false,
				autoSkip: false,
				font: {
				    size: 10
				},
				color: '#6b7280',
				padding: 8
			    },
			    grid: {
				display: false
			    }
			}
                    },
                    animation: {
                        duration: 750,
                        easing: 'easeInOutQuart'
                    },
                    layout: {
                        padding: {
                            left: containerId === 'performanceChart' ? 200 : 250, // Performance μ°¨νΈλ” padding μ¤„μ„
                            right: 60, // μμΉ ν‘μ‹ κ³µκ°„ ν™•λ³΄
                            top: 10,
                            bottom: 10
                        }
                    }
                },
                plugins: [
			{
			    // β… λ‹«ν λ¨λΈ(λ„¤κ°€ μ§€μ •ν• λ¨λΈλ“¤)λ§ λΉ—κΈ ν¨ν„΄
			    id: 'closedWeightHatch',
			    afterDatasetsDraw: (chart) => {
				const ctx = chart.ctx;
				const meta = chart.getDatasetMeta(0);
				const iconData = chart.iconData;
				if (!iconData || !iconData.filteredData) return;

				ctx.save();
				ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)'; // λΉ—κΈ μƒ‰
				ctx.lineWidth = 1;

				meta.data.forEach((bar, index) => {
				    const model = iconData.filteredData[index];
				    if (!model || !closedWeightModelSet.has(model.name)) return;

				    const { x, y, base, height } = bar;
				    const left   = Math.min(base, x);
				    const right  = Math.max(base, x);
				    const top    = y - height / 2;
				    const bottom = y + height / 2;
				    const width  = right - left;

				    ctx.save();
				    // λ§‰λ€ μμ—­λ§ ν΄λ¦¬ν•‘
				    ctx.beginPath();
				    ctx.rect(left, top, width, height);
				    ctx.clip();

				    // λ€κ°μ„  λΉ—κΈ
				    const step = 6; // κ°„κ²©
				    for (let i = -height; i < width + height; i += step) {
					ctx.beginPath();
					ctx.moveTo(left + i, bottom);
					ctx.lineTo(left + i - height, top);
					ctx.stroke();
				    }

				    ctx.restore();
				});

				ctx.restore();
			    }
			},
			{
                    id: 'valueLabel',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0);
                        const iconData = chart.iconData;
                        const scores = chart.data.datasets[0]?.data || [];

                        meta.data.forEach((bar, index) => {
                            const score = scores[index];
                            const rawScore = iconData?.filteredData?.[index]?.rawScore;
                            if (score !== null && score !== undefined) {
                                const x = bar.x;
                                const y = bar.y;

                                ctx.save();
                                ctx.fillStyle = '#374151';
                                ctx.font = '600 11px Inter';
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'middle';
                                
                                // μ •κ·ν™” μ μ ν‘μ‹
                                ctx.fillText(`${score.toFixed(1)}`, x + 5, y - 5);
                                
                                // μ›μ μ ν‘μ‹ (μλ” κ²½μ°)
                                if (rawScore !== null && rawScore !== undefined) {
                                    ctx.font = '400 9px Inter';
                                    ctx.fillStyle = '#6b7280';
                                    ctx.fillText(`(${Math.round(rawScore)})`, x + 5, y + 5);
                                }
                                
                                ctx.restore();
                            } else {
                                // N/A ν‘μ‹
                                const x = bar.x;
                                const y = bar.y;

                                ctx.save();
                                ctx.fillStyle = '#9ca3af';
                                ctx.font = '600 11px Inter';
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'middle';
                                ctx.fillText('N/A', x + 5, y);
                                ctx.restore();
                            }
                        });
                    }
                }, {
	    id: 'labelWithIcon',
	    afterDatasetsDraw: (chart) => {
		const ctx = chart.ctx;
		const yAxis = chart.scales.y;
		if (!yAxis) return;

		const iconSize = 16;
		const iconGap  = 6;   // μ•„μ΄μ½κ³Ό κΈ€μ μ‚¬μ΄ κ°„κ²©
		const iconData = chart.iconData;
		if (!iconData || !iconData.modelIcons) return;

		const meta = chart.getDatasetMeta(0);

		// yμ¶• tick ν°νΈ μ„¤μ • (Chart.js μ„¤μ •κ³Ό μµλ€ν• λ§μ¶”κΈ°)
		const tickFont   = yAxis.options.ticks.font || {};
		const fontSize   = tickFont.size   || 10;
		const fontFamily = tickFont.family || 'Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
		const fontStyle  = tickFont.style  || '';
		const fontWeight = tickFont.weight || '';
		const fontString = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;

		ctx.font = fontString;
		ctx.textBaseline = 'middle';
		ctx.textAlign = 'right';

		const labels = chart.data.labels || [];

		meta.data.forEach((bar, index) => {
		    const y = bar.y;

		    const label = labels[index] || '';
		    const iconPath = iconData.modelIcons[index];
		    if (!iconPath) return;

		    // 1) ν…μ¤νΈλ¥Ό κ·Έλ¦΄ κΈ°μ¤€ x (μ°¨νΈ μμ—­ μ™Όμ½μ—μ„ μ΅°κΈ λ–¨μ–΄μ§„ κ³³)
		    const textX = yAxis.left - 8;  // μ«μ μ¤„μ΄λ©΄ μ „μ²΄κ°€ μ™Όμ½μΌλ΅ μ΅°κΈ λ” κ°

		    // 2) λ¨Όμ € ν…μ¤νΈ κ·Έλ¦¬κΈ°
		    ctx.fillStyle = '#4b5563';
		    ctx.fillText(label, textX, y);

		    // 3) ν…μ¤νΈ ν­ μΈ΅μ •
		    const labelWidth = ctx.measureText(label).width;

		    // 4) μ•„μ΄μ½ x = (ν…μ¤νΈ μ™Όμ½) - κ°„κ²© - μ•„μ΄μ½ ν¬κΈ°
		    const labelLeftX = textX - labelWidth;
		    const iconX = labelLeftX - iconGap - iconSize;

		    const img = iconImageCache[iconPath];
		    if (img && img.complete && img.naturalWidth > 0) {
			ctx.save();
			ctx.drawImage(img, iconX, y - iconSize / 2, iconSize, iconSize);
			ctx.restore();
		    } else {
			// μ•„μ§ λ΅λ“ μ• λ κ²½μ° μΊμ‹ ν›„ μ¬λ λ”
			if (!iconImageCache[iconPath] || !iconImageCache[iconPath].complete) {
			    const newImg = new Image();
			    newImg.crossOrigin = 'anonymous';
			    newImg.onload = () => {
				iconImageCache[iconPath] = newImg;
				chart.update('none');
			    };
			    newImg.onerror = () => {
				console.warn('Failed to load icon:', iconPath);
			    };
			    newImg.src = iconPath;
			}
		    }
                        });
                    }
                }, {
                    id: 'isoftLogo',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;

                        // ν™”λ©΄ ν¬κΈ°μ— λ”°λ¥Έ μ¤μΌ€μΌ κ³„μ‚°
                        const chartWidth = chartArea.right - chartArea.left;
                        const chartHeight = chartArea.bottom - chartArea.top;
                        const scaleFactor = Math.min(chartWidth / 800, chartHeight / 600, 1); // κΈ°μ¤€ ν¬κΈ° λ€λΉ„ λΉ„μ¨
                        const scaleFactorClamped = Math.max(0.5, Math.min(1.2, scaleFactor)); // μµμ† 0.5, μµλ€ 1.2

                        // μ°¨νΈλ³„ μ„¤μ • (μ¤μΌ€μΌ μ μ©)
                        const chartId = chart.canvas?.id || '';
                        const isBaseline = chartId === 'baselineChart';
                        const baseLogoSize = isBaseline ? 48 : 38;
                        const logoSize = baseLogoSize * scaleFactorClamped;
                        const rightOffset = (isBaseline ? 70 : -20) * scaleFactorClamped;
                        const bottomOffset = 20 * scaleFactorClamped;
                        const urlPadding = 4 * scaleFactorClamped;
                        const fontSize = Math.max(9, 11 * scaleFactorClamped); // μµμ† 9px

                        // μ°ν•λ‹¨ μ„μΉ κ³„μ‚°
                        const logoX = chartArea.right - rightOffset;
                        const logoY = chartArea.bottom - bottomOffset - logoSize;

                        // λ΅κ³  μ΄λ―Έμ§€ κ·Έλ¦¬κΈ° (μΆ…ν΅λΉ„ μ μ§€)
                        let logoWidth = logoSize;
                        let logoHeight = logoSize;

                        if (isoftLogoImage && isoftLogoImage.complete && isoftLogoImage.naturalWidth > 0) {
                            ctx.save();
                            // μ›λ³Έ μ΄λ―Έμ§€μ μΆ…ν΅λΉ„ κ³„μ‚°
                            const aspectRatio = isoftLogoImage.naturalWidth / isoftLogoImage.naturalHeight;
                            logoHeight = logoSize;
                            logoWidth = logoHeight * aspectRatio;

                            // baseline μ°¨νΈλ” κ°€μ΄λ° μ •λ ¬, performance μ°¨νΈλ” μ¤λ¥Έμ½ μ •λ ¬
                            const logoDrawX = isBaseline ? logoX - logoWidth / 2 : logoX - logoWidth;
                            ctx.drawImage(isoftLogoImage, logoDrawX, logoY, logoWidth, logoHeight);
                            ctx.restore();
                        } else {
                            // λ΅κ³ κ°€ μ•„μ§ λ΅λ“λμ§€ μ•μ€ κ²½μ° μ¬μ‹λ„
                            if (!isoftLogoImage || !isoftLogoImage.complete) {
                                preloadIsoftLogo();
                                setTimeout(() => {
                                    if (chart) chart.update('none');
                                }, 100);
                            }
                        }

                        // URL ν…μ¤νΈ κ·Έλ¦¬κΈ°
                        ctx.save();
                        ctx.font = `${fontSize}px Inter, sans-serif`;
                        ctx.fillStyle = '#2563eb'; // blue-600
                        ctx.textAlign = isBaseline ? 'center' : 'right';
                        ctx.textBaseline = 'bottom';

                        const urlText = 'https://isoft.cnu.ac.kr/';
                        const urlY = logoY + logoHeight + urlPadding + (12 * scaleFactorClamped);
                        ctx.fillText(urlText, logoX, urlY);
                        ctx.restore();
                    }
                }]
            };

            // μ•„μ΄μ½ λ―Έλ¦¬ λ΅λ“
            preloadIcons();

            if (containerId === 'baselineChart') {
                baselineChart = new Chart(ctx, chartConfig);
                // μ°¨νΈμ— μ•„μ΄μ½ λ°μ΄ν„° μ €μ¥
                baselineChart.iconData = chartIconData;
                // μ•„μ΄μ½ λ΅λ“ ν›„ μ°¨νΈ μ—…λ°μ΄νΈ
                setTimeout(() => {
                    if (baselineChart) baselineChart.update('none');
                }, 500);
            } else if (containerId === 'performanceChart') {
                performanceChart = new Chart(ctx, chartConfig);
                // μ°¨νΈμ— μ•„μ΄μ½ λ°μ΄ν„° μ €μ¥
                performanceChart.iconData = chartIconData;
                // μ•„μ΄μ½ λ΅λ“ ν›„ μ°¨νΈ μ—…λ°μ΄νΈ
                setTimeout(() => {
                    if (performanceChart) performanceChart.update('none');
                }, 500);
            }
        }

        // ν…μ΄λΈ” λ λ”λ§
        function renderTable(data) {
            if (!data || data.length === 0) {
                return '<div class="text-center py-12 text-gray-500">λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤.</div>';
            }

            let html = `
                <div class="bg-white rounded-lg border border-gray-200 overflow-hidden">
                    <div class="bg-gradient-to-r from-purple-600 to-purple-700 px-4 py-3">
                        <h3 class="text-white font-semibold">Leaderboard Rankings</h3>
                    </div>
                    <div class="overflow-y-auto max-h-[600px]">
                        <table class="w-full">
                            <thead class="bg-gray-50 sticky top-0 z-10">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-semibold text-gray-700 uppercase tracking-wider">Rank</th>
                                    <th class="px-4 py-3 text-left text-xs font-semibold text-gray-700 uppercase tracking-wider">Model</th>
                                    <th class="px-4 py-3 text-right text-xs font-semibold text-gray-700 uppercase tracking-wider" data-ko="μ μ" data-en="Score">Score</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-200">
            `;

            data.forEach((item, index) => {
                const rankIcon = index === 0 ? 'π¥‡' : index === 1 ? 'π¥' : index === 2 ? 'π¥‰' : '';
                const scoreColor = item.score === null ? 'text-gray-400' :
                                 item.score >= 90 ? 'text-green-600' :
                                 item.score >= 70 ? 'text-yellow-600' : 'text-red-600';
                const bgColor = index < 3 ? 'bg-purple-25' : '';

                html += `
                    <tr class="hover:bg-purple-50 transition-colors ${bgColor}">
                        <td class="px-4 py-3 whitespace-nowrap">
                            <div class="flex items-center space-x-2">
                                ${rankIcon ? `<span>${rankIcon}</span>` : ''}
                                <span class="font-semibold text-gray-700">${item.score !== null ? `#${item.rank}` : 'N/A'}</span>
                            </div>
                        </td>
			<td class="px-4 py-3">
			    <div class="flex items-center gap-2">
				${
				    (modelIconMap[item.name])
				    ? `<img src="${modelIconMap[item.name]}" class="w-5 h-5 object-contain" />`
				    : ''
				}
				<span class="text-sm font-medium text-gray-900">${item.displayName}</span>
			    </div>
			</td>
                        <td class="px-4 py-3 text-right whitespace-nowrap">
                            <div class="flex flex-col items-end">
                                <span class="text-lg font-bold ${scoreColor}">
                                    ${item.score !== null ? `${item.score.toFixed(1)}${currentLanguage === 'ko' ? 'μ ' : ''}` : 'N/A'}
                                </span>
                                ${item.rawScore !== null && item.rawScore !== undefined ? `
                                    <span class="text-xs text-gray-500 mt-1">
                                        (${Math.round(item.rawScore)}${currentLanguage === 'ko' ? 'μ ' : ' points'})
                                    </span>
                                ` : ''}
                            </div>
                        </td>
                    </tr>
                `;
            });

            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            return html;
        }

        // Baseline μ„Ήμ… μ—…λ°μ΄νΈ
        function updateBaselineSection() {
            const data = getFilteredData('Korean', 'Text');
            const content = document.getElementById('baselineContent');

            if (!data) {
                content.innerHTML = '<div class="text-center py-12 text-gray-500" data-ko="Baseline λ°μ΄ν„°λ¥Ό μ°Ύμ„ μ μ—†μµλ‹λ‹¤." data-en="Baseline data not found.">Baseline λ°μ΄ν„°λ¥Ό μ°Ύμ„ μ μ—†μµλ‹λ‹¤.</div>';
                return;
            }

            const hasNullScores = data.some(m => m.score === null);

            const chartHtml = `
                <div class="bg-white rounded-lg border border-gray-200 p-4">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold text-gray-800">Baseline Performance Chart</h3>
                        <button onclick="downloadChart('baselineChart', 'baseline_Korean_Text')"
                                class="flex items-center space-x-2 bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg transition-colors shadow-md">
                            <span class="text-sm font-medium">π“¥ Download Chart</span>
                        </button>
                    </div>
                    ${hasNullScores ? `
                    <div class="mb-4 bg-yellow-50 border-l-4 border-yellow-400 p-3">
                        <p class="text-sm text-yellow-800">
                            <strong data-ko="μ°Έκ³ :" data-en="Note:">μ°Έκ³ :</strong>
                            <span data-ko="μΌλ¶€ λ¨λΈμ€ μ΄λ―Έμ§€ μ…λ ¥μ„ μ§€μ›ν•μ§€ μ•μ•„ ν•΄λ‹Ή μ΅°κ±΄μ—μ„ λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤. N/Aλ΅ ν‘μ‹λ λ¨λΈμ€ ν•΄λ‹Ή μ΅°κ±΄μ—μ„ ν‰κ°€λμ§€ μ•μ•μµλ‹λ‹¤."
                                  data-en="Some models do not support image input, so there is no data for these conditions. Models marked as N/A were not evaluated under these conditions.">
                                μΌλ¶€ λ¨λΈμ€ μ΄λ―Έμ§€ μ…λ ¥μ„ μ§€μ›ν•μ§€ μ•μ•„ ν•΄λ‹Ή μ΅°κ±΄μ—μ„ λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤.
                                N/Aλ΅ ν‘μ‹λ λ¨λΈμ€ ν•΄λ‹Ή μ΅°κ±΄μ—μ„ ν‰κ°€λμ§€ μ•μ•μµλ‹λ‹¤.
                            </span>
                        </p>
                    </div>
                    ` : ''}
                    <div class="mb-4 flex gap-4 text-sm">
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-green-500"></div>
                            <span data-ko="90μ  μ΄μƒ" data-en="90 score and above">90μ  μ΄μƒ</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-yellow-500"></div>
                            <span data-ko="70-90μ " data-en="70-90 score">70-90μ </span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-red-500"></div>
                            <span data-ko="70μ  λ―Έλ§" data-en="Below 70 score">70μ  λ―Έλ§</span>
                        </div>
		    <div class="flex items-center gap-2">
			<div
			    class="w-4 h-4 rounded border border-gray-500"
			    style="
				background-image: repeating-linear-gradient(
				    45deg,
				    rgba(107,114,128,0.8) 0,
				    rgba(107,114,128,0.8) 1px,
				    transparent 1px,
				    transparent 4px
				);
			    ">
			</div>
			<span data-ko="Closed λ¨λΈ" data-en="Closed-weight model">Closed-weight model</span>
		    </div>
			<div class="flex items-center gap-2">
			    <div
				class="w-4 h-4 rounded border border-gray-500 bg-white-200">
			    </div>
			    <span data-ko="Open λ¨λΈ" data-en="Open-weighted model">Open-weighted model</span>
			</div>
                    </div>
                    <div class="h-[600px]" style="position: relative;">
                        <canvas id="baselineChart"></canvas>
                    </div>
                </div>
            `;

            content.innerHTML = chartHtml;

            setTimeout(() => {
                renderHorizontalBarChart(data, 'baselineChart', 'Baseline Performance');
                setLanguage(currentLanguage); // μ–Έμ–΄ μ „ν™ μ¬μ μ©
            }, 100);
        }

        // μ„±λ¥ μ„Ήμ… μ—…λ°μ΄νΈ
        function updatePerformanceSection() {
            const language = document.getElementById('languageFilter').value;
            const modality = document.getElementById('modalityFilter').value;
            const category = document.getElementById('categoryFilter')?.value || 'ALL';

            const data = getFilteredData(language, modality, category);
            const content = document.getElementById('performanceContent');

            if (!data) {
                content.innerHTML = '<div class="text-center py-12 text-red-500" data-ko="μ„ νƒν• ν•„ν„° μ΅°κ±΄μ— ν•΄λ‹Ήν•λ” λ°μ΄ν„°λ¥Ό μ°Ύμ„ μ μ—†μµλ‹λ‹¤." data-en="No data found for the selected filter conditions.">μ„ νƒν• ν•„ν„° μ΅°κ±΄μ— ν•΄λ‹Ήν•λ” λ°μ΄ν„°λ¥Ό μ°Ύμ„ μ μ—†μµλ‹λ‹¤.</div>';
                document.getElementById('fullTableContent').innerHTML = '<div class="text-center py-12 text-red-500" data-ko="λ°μ΄ν„°λ¥Ό μ°Ύμ„ μ μ—†μµλ‹λ‹¤." data-en="Data not found.">λ°μ΄ν„°λ¥Ό μ°Ύμ„ μ μ—†μµλ‹λ‹¤.</div>';
                return;
            }

            const hasNullScores = data.some(m => m.score === null);
            const isImageModality = modality === 'Image' || modality === 'Text+Image';

            // Download λ²„νΌ ν‘μ‹ λ° μ—…λ°μ΄νΈ
            const downloadBtn = document.getElementById('downloadPerformanceChartBtn');
            if (downloadBtn) {
                downloadBtn.style.display = 'flex';
                downloadBtn.setAttribute('onclick', `downloadChart('performanceChart', '${language}_${modality}')`);
            }

            const chartHtml = `
                <div class="bg-white rounded-lg border border-gray-200 p-4">
                    <div class="mb-4">
                        <h3 class="text-lg font-semibold text-gray-800">Performance Visualization</h3>
                    </div>
                    ${hasNullScores && isImageModality ? `
                    <div class="mb-4 bg-yellow-50 border-l-4 border-yellow-400 p-3">
                        <p class="text-sm text-yellow-800">
                            <strong data-ko="μ°Έκ³ :" data-en="Note:">μ°Έκ³ :</strong>
                            <span data-ko="μΌλ¶€ λ¨λΈμ€ μ΄λ―Έμ§€ μ…λ ¥μ„ μ§€μ›ν•μ§€ μ•μ•„ ν•΄λ‹Ή μ΅°κ±΄μ—μ„ λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤. N/Aλ΅ ν‘μ‹λ λ¨λΈμ€ ν•΄λ‹Ή μ΅°κ±΄μ—μ„ ν‰κ°€λμ§€ μ•μ•μµλ‹λ‹¤."
                                  data-en="Some models do not support image input, so there is no data for these conditions. Models marked as N/A were not evaluated under these conditions.">
                                μΌλ¶€ λ¨λΈμ€ μ΄λ―Έμ§€ μ…λ ¥μ„ μ§€μ›ν•μ§€ μ•μ•„ ν•΄λ‹Ή μ΅°κ±΄μ—μ„ λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤.
                                N/Aλ΅ ν‘μ‹λ λ¨λΈμ€ ν•΄λ‹Ή μ΅°κ±΄μ—μ„ ν‰κ°€λμ§€ μ•μ•μµλ‹λ‹¤.
                            </span>
                        </p>
                    </div>
                    ` : ''}
                    <div class="mb-4 flex gap-4 text-sm">
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-green-500"></div>
                            <span data-ko="90μ  μ΄μƒ" data-en="90 score and above">90μ  μ΄μƒ</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-yellow-500"></div>
                            <span data-ko="70-90μ " data-en="70-90 score">70-90μ </span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-red-500"></div>
                            <span data-ko="70μ  λ―Έλ§" data-en="Below 70 score">70μ  λ―Έλ§</span>
                        </div>
		    <div class="flex items-center gap-2">
			<div
			    class="w-4 h-4 rounded border border-gray-500"
			    style="
				background-image: repeating-linear-gradient(
				    45deg,
				    rgba(107,114,128,0.8) 0,
				    rgba(107,114,128,0.8) 1px,
				    transparent 1px,
				    transparent 4px
				);
			    ">
			</div>
			<span data-ko="Closed λ¨λΈ" data-en="Closed-weight model">Closed-weight model</span>
		    </div>
			<div class="flex items-center gap-2">
			    <div
				class="w-4 h-4 rounded border border-gray-500 bg-white-200">
			    </div>
			    <span data-ko="Open λ¨λΈ" data-en="Open-weighted model">Open-weighted model</span>
			</div>
                    </div>
                    <div class="h-[600px]" style="position: relative;">
                        <canvas id="performanceChart"></canvas>
                    </div>
                </div>
            `;

            content.innerHTML = chartHtml;

            setTimeout(() => {
                renderHorizontalBarChart(data, 'performanceChart', 'Performance Comparison');
                // ν…μ΄λΈ”λ„ ν•¨κ» μ—…λ°μ΄νΈ
                updateFullTableSection();
                // Latency & Performance μ°¨νΈ μ—…λ°μ΄νΈ
                updateLatencyPerformanceSection();
                setLanguage(currentLanguage); // μ–Έμ–΄ μ „ν™ μ¬μ μ©
            }, 100);
        }

        // μ „μ²΄ ν…μ΄λΈ” μ„Ήμ… μ—…λ°μ΄νΈ
        function updateFullTableSection() {
            const language = document.getElementById('languageFilter')?.value || 'Korean';
            const modality = document.getElementById('modalityFilter')?.value || 'Text';
            const category = document.getElementById('categoryFilter')?.value || 'ALL';

            const data = getFilteredData(language, modality, category);
            const content = document.getElementById('fullTableContent');

            if (!data) {
                content.innerHTML = '<div class="text-center py-12 text-gray-500" data-ko="λ°μ΄ν„°λ¥Ό μ°Ύμ„ μ μ—†μµλ‹λ‹¤." data-en="Data not found.">λ°μ΄ν„°λ¥Ό μ°Ύμ„ μ μ—†μµλ‹λ‹¤.</div>';
                return;
            }

            content.innerHTML = renderTable(data);
            // μ–Έμ–΄ μ¬μ μ©
            setLanguage(currentLanguage);
        }

        // Reasoning λ°μ΄ν„° νμ‹± (λ¨λ‹¬λ¦¬ν‹°λ³„)
        function parseReasoningData(modality = null) {
            if (!parsedData || !parsedData.reasoningRows) return null;

            const result = [];

            parsedData.reasoningRows.forEach(row => {
                const effortMatch = row.name.match(/reasoning effort: (\w+)/);
                const verbosityMatch = row.name.match(/text verbositiy: (\w+)/);

                if (effortMatch && verbosityMatch) {
                    const effort = effortMatch[1];
                    const verbosity = verbosityMatch[1];

                    // λ¨λ‹¬λ¦¬ν‹° ν•„ν„°λ§
                    const filteredData = modality
                        ? row.data.filter(d => d.modality === modality)
                        : row.data;

                    const validScores = filteredData.map(d => d.value).filter(s => s !== null);
                    if (validScores.length > 0) {
                        const avg = validScores.reduce((a, b) => a + b, 0) / validScores.length;
                        const max = Math.max(...validScores);
                        const min = Math.min(...validScores);

                        result.push({
                            effort,
                            verbosity,
                            modality: modality || 'All',
                            average: avg,
                            max,
                            min
                        });
                    }
                }
            });

            return result;
        }

        // Latency & Performance μ„Ήμ… μ—…λ°μ΄νΈ
        function updateLatencyPerformanceSection() {
            if (!parsedData || !latencyData) {
                const content = document.getElementById('latencyPerformanceContent');
                if (content) {
                    content.innerHTML = '<div class="text-center py-12 text-gray-500" data-ko="Latency λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘..." data-en="Loading latency data...">Latency λ°μ΄ν„°λ¥Ό λ΅λ“ν•λ” μ¤‘...</div>';
                }
                return;
            }

            const language = document.getElementById('languageFilter')?.value || 'Korean';
            const modality = document.getElementById('modalityFilter')?.value || 'Text';
            const category = document.getElementById('categoryFilter')?.value || 'ALL';

            const content = document.getElementById('latencyPerformanceContent');
            
            // Problem Category ν•„ν„°κ°€ ALLμ΄ μ•„λ‹ κ²½μ° μ•λ‚΄ λ©”μ‹μ§€ ν‘μ‹
            if (category !== 'ALL') {
                content.innerHTML = `
                    <div class="bg-blue-50 border-l-4 border-blue-500 p-5 rounded-r-lg">
                        <p class="text-gray-700 leading-relaxed" 
                           data-ko="Latency & Performance μ°¨νΈλ” μ „μ²΄ λ¬Έμ (ALL)μ— λ€ν•΄μ„λ§ μ κ³µλ©λ‹λ‹¤. λ¬Έμ  μΉ΄ν…κ³ λ¦¬λ³„ Latency λ°μ΄ν„°λ” ν„μ¬ μ κ³µλμ§€ μ•μµλ‹λ‹¤." 
                           data-en="Latency & Performance chart is only available for all problems (ALL). Category-specific latency data is not currently available.">
                            Latency & Performance μ°¨νΈλ” μ „μ²΄ λ¬Έμ (ALL)μ— λ€ν•΄μ„λ§ μ κ³µλ©λ‹λ‹¤. λ¬Έμ  μΉ΄ν…κ³ λ¦¬λ³„ Latency λ°μ΄ν„°λ” ν„μ¬ μ κ³µλμ§€ μ•μµλ‹λ‹¤.
                        </p>
                    </div>
                `;
                return;
            }

            const performanceData = getFilteredData(language, modality, category);

            if (!performanceData || performanceData.length === 0) {
                content.innerHTML = '<div class="text-center py-12 text-gray-500" data-ko="λ°μ΄ν„°λ¥Ό μ°Ύμ„ μ μ—†μµλ‹λ‹¤." data-en="Data not found.">λ°μ΄ν„°λ¥Ό μ°Ύμ„ μ μ—†μµλ‹λ‹¤.</div>';
                return;
            }

            // Latency λ°μ΄ν„°μ™€ Performance λ°μ΄ν„° κ²°ν•©
            const combinedData = performanceData
                .map(item => {
                    const latencyKey = `${language}_${modality}`;
                    const latency = latencyData[item.name]?.[latencyKey] || null;
                    return {
                        ...item,
                        latency: latency,
                        overBaseline: latency !== null && latency > BASELINE_TIME
                    };
                })
                .filter(item => item.latency !== null) // latencyκ°€ μλ” λ¨λΈλ§
                .sort((a, b) => a.latency - b.latency); // latency μμΌλ΅ μ •λ ¬

            if (combinedData.length === 0) {
                content.innerHTML = '<div class="text-center py-12 text-gray-500" data-ko="Latency λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤." data-en="No latency data available.">Latency λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤.</div>';
                return;
            }

            const chartHtml = `
                <div class="bg-white rounded-lg border border-gray-200 p-4">
                    <div class="flex justify-between items-center mb-4">
                        <div></div>
                        <button onclick="downloadChart('latencyPerformanceChart', 'latency_performance_${language}_${modality}')"
                                class="flex items-center space-x-2 bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg transition-colors shadow-md">
                            <span class="text-sm font-medium">π“¥ Download Chart</span>
                        </button>
                    </div>
                    <div class="mb-4 flex gap-4 text-sm flex-wrap">
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-green-500"></div>
                            <span data-ko="Latency (λ§‰λ€) β‰¤ μ‹ν—μ‹κ°„" data-en="Latency (bar) β‰¤ Exam Time">Latency (bar) β‰¤ Exam Time</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-red-500"></div>
                            <span data-ko="Latency (λ§‰λ€) > μ‹ν—μ‹κ°„" data-en="Latency (bar) > Exam Time">Latency (bar) > Exam Time</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <svg width="20" height="4" style="display: block;">
                                <line x1="0" y1="2" x2="20" y2="2" stroke="rgba(129, 199, 132, 0.8)" stroke-width="3" stroke-linecap="round"/>
                            </svg>
                            <span data-ko="Performance (μ„ )" data-en="Performance (line)">Performance (line)</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 border-2 border-red-500" style="height: 2px; border-style: dashed;"></div>
                            <span data-ko="μ‹ν—μ‹κ°„ (152λ¶„)" data-en="Exam Time (152 minutes)">Exam Time (152 minutes)</span>
                        </div>
                    </div>
                    <div id="latencyPerformanceChartContainer" class="latency-performance-chart-container" style="background: white; padding: 16px;">
                        <div class="h-[800px]" style="position: relative;">
                            <canvas id="latencyPerformanceChart"></canvas>
                        </div>
                    </div>
                </div>
            `;

            content.innerHTML = chartHtml;

            setTimeout(() => {
                renderLatencyPerformanceChart(combinedData, 'latencyPerformanceChart', modality);
                setLanguage(currentLanguage);
            }, 100);
        }

        // Latency & Performance μ°¨νΈ λ λ”λ§
        function renderLatencyPerformanceChart(data, containerId, modality) {
            if (!data || data.length === 0) return;

            const ctx = document.getElementById(containerId);
            if (!ctx) return;

            // κΈ°μ΅΄ μ°¨νΈ μ κ±°
            if (latencyPerformanceChart) {
                latencyPerformanceChart.destroy();
            }

            const labels = data.map(m => m.displayName || m.name);
            const latencies = data.map(m => m.latency);
            const scores = data.map(m => m.score);
            const colors = data.map(m => m.overBaseline ? 'rgba(229, 115, 115, 0.8)' : 'rgba(129, 199, 132, 0.8)'); // λΉ¨κ°•/μ΄λ΅
            const borderColors = data.map(m => m.overBaseline ? 'rgba(229, 115, 115, 1)' : 'rgba(129, 199, 132, 1)');

            // μµλ€ latency κ³„μ‚°
            const maxLatency = Math.max(...latencies);
            const maxX = Math.max(maxLatency * 1.12, BASELINE_TIME * 1.15);

            const chartConfig = {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Latency (minutes)',
                            data: latencies,
                            backgroundColor: colors,
                            borderColor: borderColors,
                            borderWidth: 2,
                            borderRadius: 4,
                            yAxisID: 'y',
                            xAxisID: 'x'
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false // λ²”λ΅€ μ κ±° (μ„¤λ… λ¶€λ¶„μ— μ§μ ‘ ν‘μ‹)
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.85)',
                            padding: 12,
                            callbacks: {
                                label: (context) => {
                                    const datasetLabel = context.dataset.label || '';
                                    const value = context.parsed.x || context.parsed.y;
                                    const index = context.dataIndex;
                                    const item = data[index];
                                    
                                    if (datasetLabel.includes('Latency')) {
                                        return `Latency: ${value.toFixed(1)} minutes`;
                                    }
                                    return '';
                                },
                                afterLabel: (context) => {
                                    const index = context.dataIndex;
                                    const item = data[index];
                                    if (item) {
                                        const lines = [];
                                        if (item.score !== null && item.score !== undefined) {
                                            lines.push(`Score: ${item.score.toFixed(1)}${getScoreUnit()}`);
                                        }
                                        if (item.overBaseline) {
                                            lines.push('Exceeds exam time');
                                        } else {
                                            lines.push('Within exam time');
                                        }
                                        return lines;
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            beginAtZero: true,
                            max: maxX,
                            ticks: {
                                stepSize: 60,
                                callback: (value) => `${value}`
                            },
                            title: {
                                display: true,
                                text: 'Latency (minutes)',
                                font: {
                                    size: 14,
                                    weight: '600'
                                }
                            },
                            grid: {
                                color: 'rgba(156, 163, 175, 0.2)'
                            }
                        },
                        x1: {
                            type: 'linear',
                            position: 'top',
                            beginAtZero: true,
                            max: 105,
                            ticks: {
                                stepSize: 10,
                                callback: (value) => `${value}`
                            },
                            title: {
                                display: true,
                                text: 'Normalized Score',
                                font: {
                                    size: 14,
                                    weight: '600'
                                }
                            },
                            grid: {
                                color: 'rgba(156, 163, 175, 0.15)',
                                lineWidth: 1,
                                drawOnChartArea: true
                            }
                        },
                        y: {
                            ticks: {
                                display: false
                            },
                            grid: {
                                display: false
                            }
                        }
                    },
                    layout: {
                        padding: {
                            left: 300,
                            right: 60,
                            top: 60,
                            bottom: 80 // Exam Time λ μ΄λΈ”μ„ μ„ν• μ—¬μ  κ³µκ°„ μ¶”κ°€
                        }
                    }
                },
                plugins: [{
                    id: 'latencyScoreLines',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const xScale = chart.scales.x;
                        const x1Scale = chart.scales.x1;
                        const yScale = chart.scales.y;
                        const meta = chart.getDatasetMeta(0);
                        const chartData = chart.chartData || [];

                        // Scoreλ¥Ό μ„ μΌλ΅ κ·Έλ¦¬κΈ°
                        meta.data.forEach((bar, index) => {
                            const item = chartData[index];
                            if (!item || item.score === null || item.score === undefined) return;

                            const score = item.score;
                            const barY = bar.y; // λ§‰λ€μ μ¤‘μ•™ y μΆν‘ (ν”½μ…€)
                            const barHeightData = bar.height || 0.5; // λ§‰λ€ λ†’μ΄ (λ°μ΄ν„° λ‹¨μ„)
                            const color = item.overBaseline ? 'rgba(229, 115, 115, 0.8)' : 'rgba(129, 199, 132, 0.8)';
                            
                            // λ§‰λ€μ top μ„μΉ κ³„μ‚° (ν”½μ…€)
                            // bar.yλ” ν”½μ…€ λ‹¨μ„μ΄κ³ , bar.heightλ” λ°μ΄ν„° λ‹¨μ„μ΄λ―€λ΅ yScaleμ„ μ‚¬μ©ν•΄ λ³€ν™
                            const barYData = yScale.getValueForPixel(barY);
                            const barTopData = barYData - barHeightData / 2;
                            const barTopY = yScale.getPixelForValue(barTopData);
                            
                            // μ„  κ·Έλ¦¬κΈ° (0λ¶€ν„° scoreκΉμ§€) - κ° λ§‰λ€μ μ¤‘μ•™ yμΆν‘λ³΄λ‹¤ μ„μ— μ„μΉ
                            const x0 = x1Scale.getPixelForValue(0);
                            const x1 = x1Scale.getPixelForValue(score);
                            // Input Modalityμ— λ”°λΌ μ„μΉ μ΅°μ •
                            // text-onlyμΌ λ•λ” -11, λ‚λ¨Έμ§€(Image-only, Text+Figure)μΌ λ•λ” -18
                            const currentModality = chart.chartModality || 'Text';
                            const lineY = currentModality === 'Text' ? barY - 11 : barY - 18;
                            
                            ctx.save();
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(x0, lineY);
                            ctx.lineTo(x1, lineY);
                            ctx.stroke();
                            
                            // λμ  λ§μ»¤
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(x1, lineY, 6, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            
                            // Score κ°’ ν‘κΈ°
                            ctx.fillStyle = '#212121';
                            ctx.font = '600 11px Inter';
                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(score.toFixed(1), x1 + 8, lineY);
                            ctx.restore();
                        });
                    }
                }, {
                    id: 'latencyBaselineLine',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const xScale = chart.scales.x;
                        const yScale = chart.scales.y;
                        
                        // μ‹ν—μ‹κ°„ μμ§μ„ 
                        const xPos = xScale.getPixelForValue(BASELINE_TIME);
                        ctx.save();
                        ctx.strokeStyle = '#D32F2F';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(xPos, yScale.top);
                        ctx.lineTo(xPos, yScale.bottom);
                        ctx.stroke();
                        ctx.restore();
                        
                        // μ‹ν—μ‹κ°„ λ μ΄λΈ” - xμ¶• λ μ΄λΈ”κ³Ό κ²ΉμΉμ§€ μ•λ„λ΅ λ” μ•„λμ— λ°°μΉ
                        const labelY = yScale.bottom + 35;
                        const labelText = 'Exam Time';
                        
                        // λ μ΄λΈ” ν…μ¤νΈ ν¬κΈ° μΈ΅μ •
                        ctx.save();
                        ctx.font = '12px Inter, sans-serif';
                        const textMetrics = ctx.measureText(labelText);
                        const textWidth = textMetrics.width;
                        const textHeight = 12;
                        
                        // μ…μ€ λ…Έλ€μƒ‰ λ‘¥κ·Ό λ„¤λ¨λ°•μ¤ λ°°κ²½ κ·Έλ¦¬κΈ°
                        const padding = 8;
                        const boxWidth = textWidth + padding * 2;
                        const boxHeight = textHeight + padding * 2;
                        const boxX = xPos - boxWidth / 2;
                        const boxY = labelY - padding;
                        const borderRadius = 6;
                        
                        ctx.fillStyle = 'rgba(255, 255, 200, 0.7)'; // μ…μ€ λ…Έλ€μƒ‰
                        ctx.beginPath();
                        // λ‘¥κ·Ό μ‚¬κ°ν• κ·Έλ¦¬κΈ° (μλ™μΌλ΅)
                        ctx.moveTo(boxX + borderRadius, boxY);
                        ctx.lineTo(boxX + boxWidth - borderRadius, boxY);
                        ctx.quadraticCurveTo(boxX + boxWidth, boxY, boxX + boxWidth, boxY + borderRadius);
                        ctx.lineTo(boxX + boxWidth, boxY + boxHeight - borderRadius);
                        ctx.quadraticCurveTo(boxX + boxWidth, boxY + boxHeight, boxX + boxWidth - borderRadius, boxY + boxHeight);
                        ctx.lineTo(boxX + borderRadius, boxY + boxHeight);
                        ctx.quadraticCurveTo(boxX, boxY + boxHeight, boxX, boxY + boxHeight - borderRadius);
                        ctx.lineTo(boxX, boxY + borderRadius);
                        ctx.quadraticCurveTo(boxX, boxY, boxX + borderRadius, boxY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                        
                        // λ μ΄λΈ” ν…μ¤νΈ κ·Έλ¦¬κΈ°
                        ctx.save();
                        ctx.fillStyle = '#D32F2F';
                        ctx.font = '12px Inter, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillText(labelText, xPos, labelY);
                        ctx.restore();
                    }
                }, {
                    id: 'latencyModelLabels',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const yAxis = chart.scales.y;
                        if (!yAxis) return;

                        const meta = chart.getDatasetMeta(0);
                        const labels = chart.data.labels || [];
                        const iconSize = 16;
                        const iconGap = 6;

                        ctx.font = '11px Inter, system-ui, sans-serif';
                        ctx.textBaseline = 'middle';
                        ctx.textAlign = 'right';

                        meta.data.forEach((bar, index) => {
                            const y = bar.y;
                            const label = labels[index] || '';
                            const item = data[index];
                            
                            // λ¨λΈ μ•„μ΄μ½ ν‘μ‹
                            if (item && modelIconMap[item.name]) {
                                const iconPath = modelIconMap[item.name];
                                const textX = yAxis.left - 8;
                                ctx.fillStyle = '#4b5563';
                                ctx.fillText(label, textX, y);
                                
                                const labelWidth = ctx.measureText(label).width;
                                const labelLeftX = textX - labelWidth;
                                const iconX = labelLeftX - iconGap - iconSize;
                                
                                const img = iconImageCache[iconPath];
                                if (img && img.complete && img.naturalWidth > 0) {
                                    ctx.save();
                                    ctx.drawImage(img, iconX, y - iconSize / 2, iconSize, iconSize);
                                    ctx.restore();
                                }
                            } else {
                                const textX = yAxis.left - 8;
                                ctx.fillStyle = '#4b5563';
                                ctx.fillText(label, textX, y);
                            }
                        });
                    }
                }, {
                    id: 'latencyValueLabels',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0);
                        const latencies = chart.data.datasets[0]?.data || [];
                        const scores = chart.data.datasets[1]?.data || [];
                        const xScale = chart.scales.x;
                        const x1Scale = chart.scales.x1;

                        const chartData = chart.chartData || [];
                        
                        meta.data.forEach((bar, index) => {
                            const latency = latencies[index];
                            const item = chartData[index];
                            
                            if (latency !== null && latency !== undefined) {
                                // Latency κ°’ ν‘μ‹
                                const x = bar.x;
                                const y = bar.y;
                                const xPos = xScale.getPixelForValue(latency);
                                
                                ctx.save();
                                ctx.fillStyle = item && item.overBaseline ? '#D32F2F' : '#424242';
                                ctx.font = '600 11px Inter';
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(`${latency.toFixed(0)}min`, xPos + 5, y);
                                ctx.restore();
                            }
                        });
                    }
                }, {
                    id: 'latencyIsoftLogo',
                    afterDraw: (chart) => {
                        if (chart.exportMode === 'pdf') {
                            return;
                        }
                        
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const x1Scale = chart.scales.x1; // μƒλ‹¨ xμ¶•

                        const chartWidth = chartArea.right - chartArea.left;
                        const chartHeight = chartArea.bottom - chartArea.top;
                        const scaleFactor = Math.min(chartWidth / 800, chartHeight / 600, 1);
                        const scaleFactorClamped = Math.max(0.5, Math.min(1.2, scaleFactor));

                        const logoSize = 38 * scaleFactorClamped;
                        const rightOffset = 20 * scaleFactorClamped;
                        const topOffset = 20 * scaleFactorClamped; // μƒλ‹¨ xμ¶• κΈ°μ¤€ μ•„λ
                        const urlPadding = 4 * scaleFactorClamped;
                        const fontSize = Math.max(9, 11 * scaleFactorClamped);

                        const logoX = chartArea.right - rightOffset;
                        // μƒλ‹¨ xμ¶• μ•„λμ— μ„μΉ (x1Scaleμ bottom μ„μΉ μ‚¬μ©)
                        const logoY = x1Scale.bottom + topOffset;

                        let logoWidth = logoSize;
                        let logoHeight = logoSize;

                        if (isoftLogoImage && isoftLogoImage.complete && isoftLogoImage.naturalWidth > 0) {
                            ctx.save();
                            const aspectRatio = isoftLogoImage.naturalWidth / isoftLogoImage.naturalHeight;
                            logoHeight = logoSize;
                            logoWidth = logoHeight * aspectRatio;
                            
                            const logoDrawX = logoX - logoWidth;
                            ctx.drawImage(isoftLogoImage, logoDrawX, logoY, logoWidth, logoHeight);
                            ctx.restore();
                        } else {
                            if (!isoftLogoImage || !isoftLogoImage.complete) {
                                preloadIsoftLogo();
                                setTimeout(() => {
                                    if (chart) chart.update('none');
                                }, 100);
                            }
                        }
                        
                        ctx.save();
                        ctx.font = `${fontSize}px Inter, sans-serif`;
                        ctx.fillStyle = '#2563eb';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'top';
                        
                        const urlText = 'https://isoft.cnu.ac.kr/';
                        const urlY = logoY + logoHeight + urlPadding;
                        ctx.fillText(urlText, logoX, urlY);
                        ctx.restore();
                    }
                }]
            };

            latencyPerformanceChart = new Chart(ctx, chartConfig);
            latencyPerformanceChart.chartData = data;
            latencyPerformanceChart.chartModality = modality; // Input Modality μ •λ³΄ μ €μ¥
        }

        // Reasoning μ„Ήμ… μ—…λ°μ΄νΈ
        function updateReasoningSection() {
            const content = document.getElementById('reasoningContent');

            // λ¨λ‹¬λ¦¬ν‹°λ³„λ΅ λ°μ΄ν„° νμ‹±
            const modalities = ['Text', 'Image', 'Text+Image'];
            const modalityData = {};
            modalities.forEach(mod => {
                modalityData[mod] = parseReasoningData(mod);
            });

            // λ¨λ“  λ¨λ‹¬λ¦¬ν‹°μ— λ°μ΄ν„°κ°€ μ—†λ”μ§€ ν™•μΈ
            const hasAnyData = modalities.some(mod => modalityData[mod] && modalityData[mod].length > 0);
            if (!hasAnyData) {
                content.innerHTML = '<div class="text-center py-12 text-gray-500" data-ko="Reasoning λ¶„μ„ λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤." data-en="No reasoning analysis data available.">Reasoning λ¶„μ„ λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤.</div>';
                return;
            }

            // λ¨λ‹¬λ¦¬ν‹° μ„ νƒ λ“λ΅­λ‹¤μ΄κ³Ό μ°¨νΈ μƒμ„±
            let html = `
                <div class="gradient-filter rounded-lg p-5 border border-purple-200 mb-6">
                    <label class="block text-sm font-semibold text-gray-700 mb-2" data-ko="Input Modality" data-en="Input Modality">Input Modality</label>
                    <select id="reasoningModalityFilter" onchange="updateReasoningChart()" class="w-full md:w-auto appearance-none bg-white border border-gray-300 rounded-lg px-4 py-2.5 pr-10 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all cursor-pointer">
                        ${modalities.map(mod => `<option value="${mod}">${mod}</option>`).join('')}
                    </select>
                </div>
            `;

            // κ° λ¨λ‹¬λ¦¬ν‹°λ³„λ΅ μ°¨νΈμ™€ ν…μ΄λΈ” μƒμ„±
            modalities.forEach((modality, modIdx) => {
                const data = modalityData[modality] || [];
                if (data.length === 0) return;

                const chartId = `reasoningChart_${modality.replace('+', 'Plus')}`;
                const tableId = `reasoningTable_${modality.replace('+', 'Plus')}`;
                const displayStyle = modIdx === 0 ? 'block' : 'none';

                html += `
                    <div id="reasoning_${modality.replace('+', 'Plus')}" class="reasoning-modality-section" style="display: ${displayStyle};">
                        ${renderReasoningTable(data, tableId, modality)}
                    </div>
                `;
            });

            content.innerHTML = html;

            // μ΄κΈ° λ¨λ‹¬λ¦¬ν‹° ν‘μ‹
            setTimeout(() => {
                updateReasoningChart();
                setLanguage(currentLanguage);
            }, 200);
        }

        // Reasoning μ°¨νΈ λ λ”λ§
        function renderReasoningChart(data, chartId, modality) {
            const efforts = ['minimal', 'low', 'medium', 'high'];
            const verbosities = ['low', 'medium', 'high'];
            const verbosityColors = {
                'low': '#3b82f6',
                'medium': '#f59e0b',
                'high': '#8b5cf6'
            };

            return `
                <div class="bg-white rounded-lg border border-gray-200 p-4 mb-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold text-gray-800">Reasoning Performance - ${modality}</h3>
                        <button onclick="downloadChart('${chartId}', 'gpt5_reasoning_${modality}')"
                                class="flex items-center space-x-2 bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg transition-colors shadow-md">
                            <span class="text-sm font-medium">π“¥ Download Chart</span>
                        </button>
                    </div>
                    <div class="h-[500px]">
                        <canvas id="${chartId}"></canvas>
                    </div>
                </div>
            `;
        }

        // Reasoning ν…μ΄λΈ” λ λ”λ§
        function renderReasoningTable(data, tableId, modality) {
            let tableHtml = `
                <div class="bg-white rounded-lg border border-gray-200 p-4 mb-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4" data-ko="Reasoning Performance - ${modality}" data-en="Reasoning Performance - ${modality}">Reasoning Performance - ${modality}</h3>
                    <div class="overflow-x-auto">
                        <table class="w-full border-collapse">
                            <thead>
                                <tr class="bg-gray-50">
                                    <th class="px-4 py-3 text-left text-xs font-semibold text-gray-700 uppercase" data-ko="Reasoning Effort" data-en="Reasoning Effort">Reasoning Effort</th>
                                    <th class="px-4 py-3 text-left text-xs font-semibold text-gray-700 uppercase" data-ko="Verbosity" data-en="Verbosity">Verbosity</th>
                                    <th class="px-4 py-3 text-right text-xs font-semibold text-gray-700 uppercase" data-ko="Performance" data-en="Performance">Performance</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-200">
            `;

            const effortOrder = { 'minimal': 0, 'low': 1, 'medium': 2, 'high': 3 };
            const verbOrder = { 'low': 0, 'medium': 1, 'high': 2 };
            const effortColors = {
                'minimal': 'bg-blue-50',
                'low': 'bg-purple-50',
                'medium': 'bg-pink-50',
                'high': 'bg-indigo-50'
            };
            const verbosityColors = {
                'low': 'bg-cyan-50',
                'medium': 'bg-amber-50',
                'high': 'bg-rose-50'
            };

            data.sort((a, b) => {
                if (effortOrder[a.effort] !== effortOrder[b.effort]) {
                    return effortOrder[a.effort] - effortOrder[b.effort];
                }
                return verbOrder[a.verbosity] - verbOrder[b.verbosity];
            }).forEach((item, index) => {
                const avgColor = item.average >= 90 ? 'text-green-600' : item.average >= 70 ? 'text-yellow-600' : 'text-red-600';
                // effortμ™€ verbosityμ— λ”°λΌ λ°°κ²½μƒ‰ μ μ©
                const effortBgColor = effortColors[item.effort] || 'bg-gray-50';
                const verbBgColor = verbosityColors[item.verbosity] || 'bg-gray-50';

                tableHtml += `
                    <tr class="hover:bg-gray-50">
                        <td class="px-4 py-3 text-sm"><span class="px-2 py-1 rounded ${effortBgColor}">${item.effort}</span></td>
                        <td class="px-4 py-3 text-sm"><span class="px-2 py-1 rounded ${verbBgColor}">${item.verbosity}</span></td>
                        <td class="px-4 py-3 text-right text-sm font-semibold ${avgColor}">${item.average.toFixed(1)}${getScoreUnit()}</td>
                    </tr>
                `;
            });

            tableHtml += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            return tableHtml;
        }

        // Reasoning μ°¨νΈ μ—…λ°μ΄νΈ (ν…μ΄λΈ”λ§ ν‘μ‹)
        function updateReasoningChart() {
            const selectedModality = document.getElementById('reasoningModalityFilter')?.value;
            if (!selectedModality) return;

            const modalities = ['Text', 'Image', 'Text+Image'];

            // λ¨λ“  μ„Ήμ… μ¨κΈ°κΈ°
            modalities.forEach(mod => {
                const section = document.getElementById(`reasoning_${mod.replace('+', 'Plus')}`);
                if (section) section.style.display = 'none';
            });

            // μ„ νƒλ μ„Ήμ… ν‘μ‹
            const selectedSection = document.getElementById(`reasoning_${selectedModality.replace('+', 'Plus')}`);
            if (selectedSection) selectedSection.style.display = 'block';
        }

        // λ¨λΈλ³„ Best μ„±λ¥ μ„Ήμ… μ—…λ°μ΄νΈ
        function updateBestPerformanceSection() {
            if (!parsedData) return;

            const content = document.getElementById('bestPerformanceContent');
            const bestScores = [];

            // κ° λ¨λΈμ— λ€ν•΄ λ¨λ“  μ–Έμ–΄μ™€ λ¨λ‹¬λ¦¬ν‹° μ΅°ν•© μ¤‘ μµκ³  μ„±λ¥ μ°ΎκΈ°
            parsedData.models.forEach(model => {
                let bestScore = null;
                let bestConfigs = []; // λ™μΌν• λ² μ¤νΈ μ μλ¥Ό κ°€μ§„ λ¨λ“  μ΅°ν•© μ €μ¥

                parsedData.columnMap.forEach((col, index) => {
                    const score = model.scores[index];
                    if (score && score.value !== null) {
                        if (bestScore === null || score.value > bestScore) {
                            bestScore = score.value;
                            bestConfigs = [{
                                language: col.language,
                                modality: col.modality
                            }];
                        } else if (score.value === bestScore) {
                            // λ™μΌν• λ² μ¤νΈ μ μλ¥Ό κ°€μ§„ μ΅°ν•© μ¶”κ°€
                            bestConfigs.push({
                                language: col.language,
                                modality: col.modality
                            });
                        }
                    }
                });

                if (bestScore !== null) {
                    // μ‹¤μ  μ μ κ³„μ‚°
                    const rawScore = Math.round((bestScore / 100) * 152);
                    
                    // λ¨λ“  λ² μ¤νΈ μ΅°ν•©μ— λ€ν•΄ ν•­λ© μƒμ„±
                    bestConfigs.forEach(config => {
                        bestScores.push({
                            name: model.name,
                            displayName: modelNameMap[model.name] || model.name,
                            score: bestScore,
                            rawScore: rawScore,
                            config: config
                        });
                    });
                }
            });

            // μ μμμΌλ΅ μ •λ ¬
            bestScores.sort((a, b) => b.score - a.score);

            if (bestScores.length === 0) {
                content.innerHTML = '<div class="text-center py-12 text-gray-500" data-ko="λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤." data-en="No data available.">λ°μ΄ν„°κ°€ μ—†μµλ‹λ‹¤.</div>';
                return;
            }

            const chartHtml = `
                <div class="bg-white rounded-lg border border-gray-200 p-4">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold text-gray-800" data-ko="Model Best Performance Chart" data-en="Model Best Performance Chart">Model Best Performance Chart</h3>
                        <button onclick="downloadChart('bestPerformanceChart', 'best_performance')"
                                class="flex items-center space-x-2 bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg transition-colors shadow-md">
                            <span class="text-sm font-medium">π“¥ Download Chart</span>
                        </button>
                    </div>
                    <div class="mb-4 flex gap-4 text-sm">
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-green-500"></div>
                            <span data-ko="90μ  μ΄μƒ" data-en="90 score and above">90μ  μ΄μƒ</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-yellow-500"></div>
                            <span data-ko="70-90μ " data-en="70-90 score">70-90μ </span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded bg-red-500"></div>
                            <span data-ko="70μ  λ―Έλ§" data-en="Below 70 score">70μ  λ―Έλ§</span>
                        </div>
                    </div>
                    <div id="bestPerformanceChartContainer" class="best-performance-chart-container" style="background: white; padding: 16px;">
                        <div class="h-[600px]" style="position: relative;">
                            <canvas id="bestPerformanceChart"></canvas>
                        </div>
                    </div>
                </div>
            `;

            content.innerHTML = chartHtml;

            setTimeout(() => {
                renderBestPerformanceChart(bestScores, 'bestPerformanceChart');
                setLanguage(currentLanguage);
            }, 100);
        }

        // Best μ„±λ¥ μ°¨νΈ λ λ”λ§
        function renderBestPerformanceChart(data, containerId) {
            if (!data || data.length === 0) return;

            const ctx = document.getElementById(containerId);
            if (!ctx) return;

            // κΈ°μ΅΄ μ°¨νΈ μ κ±°
            if (bestPerformanceChart) {
                bestPerformanceChart.destroy();
            }

            // λΌλ²¨μ— λ¨λΈ μ΄λ¦„κ³Ό μ΅°ν•© μ •λ³΄ ν¬ν•¨
            const labels = data.map(m => {
                const modelName = m.displayName || m.name;
                const config = m.config;
                if (config) {
                    return `${modelName} (${config.language}, ${config.modality})`;
                }
                return modelName;
            });
            const scores = data.map(m => m.score);
            const chartData = data; // ν”λ¬κ·ΈμΈμ—μ„ μ‚¬μ©ν•κΈ° μ„ν•΄ μ €μ¥

            const chartConfig = {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Best Performance',
                        data: scores,
                        backgroundColor: scores.map(score => getBarColor(score)),
                        borderColor: scores.map(score => getBorderColor(score)),
                        borderWidth: 2,
                        borderRadius: 6
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.85)',
                            padding: 12,
                            callbacks: {
                                afterLabel: (context) => {
                                    const item = data[context.dataIndex];
                                    const lines = [];
                                    if (item && item.config) {
                                        lines.push(`Language: ${item.config.language}`);
                                        lines.push(`Modality: ${item.config.modality}`);
                                    }
                                    if (item && item.rawScore !== null && item.rawScore !== undefined) {
                                        lines.push(`Raw Score: ${item.rawScore}${currentLanguage === 'ko' ? 'μ ' : ' points'}`);
                                    }
                                    return lines;
                                },
                                label: (context) => {
                                    const score = scores[context.dataIndex];
                                    return `Best Score: ${score.toFixed(1)}${getScoreUnit()}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                stepSize: 10
                            },
                            title: {
                                display: true,
                                text: 'Normalized Score'
                            }
                        },
                        y: {
                            ticks: {
                                display: false
                            },
                            grid: {
                                display: false
                            }
                        }
                    },
                    layout: {
                        padding: {
                            left: 300, // λ¨λΈ μ΄λ¦„κ³Ό μ΅°ν•© μ •λ³΄λ¥Ό μ„ν• κ³µκ°„ ν™•λ³΄
                            right: 60,
                            top: 10,
                            bottom: 10
                        }
                    }
                },
                plugins: [{
                    id: 'bestPerformanceLabels',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const yAxis = chart.scales.y;
                        if (!yAxis) return;

                        const meta = chart.getDatasetMeta(0);
                        const labels = chart.data.labels || [];
                        const iconSize = 16;
                        const iconGap = 6;

                        ctx.font = '10px Inter, system-ui, sans-serif';
                        ctx.textBaseline = 'middle';
                        ctx.textAlign = 'right';

                        const chartData = chart.chartData || [];
                        
                        meta.data.forEach((bar, index) => {
                            const y = bar.y;
                            const label = labels[index] || '';
                            const item = chartData[index];
                            
                            // λ¨λΈ μ•„μ΄μ½ ν‘μ‹
                            if (item && modelIconMap[item.name]) {
                                const iconPath = modelIconMap[item.name];
                                const textX = yAxis.left - 8;
                                ctx.fillStyle = '#4b5563';
                                ctx.fillText(label, textX, y);
                                
                                const labelWidth = ctx.measureText(label).width;
                                const labelLeftX = textX - labelWidth;
                                const iconX = labelLeftX - iconGap - iconSize;
                                
                                const img = iconImageCache[iconPath];
                                if (img && img.complete && img.naturalWidth > 0) {
                                    ctx.save();
                                    ctx.drawImage(img, iconX, y - iconSize / 2, iconSize, iconSize);
                                    ctx.restore();
                                }
                            } else {
                                // μ•„μ΄μ½μ΄ μ—†λ” κ²½μ° ν…μ¤νΈλ§
                                const textX = yAxis.left - 8;
                                ctx.fillStyle = '#4b5563';
                                ctx.fillText(label, textX, y);
                            }
                        });
                    }
                }, {
                    id: 'bestPerformanceValueLabel',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0);
                        const scores = chart.data.datasets[0]?.data || [];
                        const chartData = chart.chartData || [];

                        meta.data.forEach((bar, index) => {
                            const score = scores[index];
                            const item = chartData[index];
                            if (score !== null && score !== undefined) {
                                const x = bar.x;
                                const y = bar.y;

                                ctx.save();
                                // μ •κ·ν™” μ μ ν‘μ‹
                                ctx.fillStyle = '#374151';
                                ctx.font = '600 11px Inter';
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(score.toFixed(1), x + 5, y - 5);
                                
                                // μ‹¤μ  μ μ ν‘μ‹ (μλ” κ²½μ°)
                                if (item && item.rawScore !== null && item.rawScore !== undefined) {
                                    ctx.font = '400 9px Inter';
                                    ctx.fillStyle = '#6b7280';
                                    ctx.fillText(`(${item.rawScore})`, x + 5, y + 5);
                                }
                                ctx.restore();
                            }
                        });
                    }
                }, {
                    id: 'bestPerformanceIsoftLogo',
                    afterDraw: (chart) => {
                        // PDF μ €μ¥ λ¨λ“μΌ λ•λ” λ΅κ³ λ¥Ό κ·Έλ¦¬μ§€ μ•μ
                        if (chart.exportMode === 'pdf') {
                            return;
                        }
                        
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;

                        // ν™”λ©΄ ν¬κΈ°μ— λ”°λ¥Έ μ¤μΌ€μΌ κ³„μ‚°
                        const chartWidth = chartArea.right - chartArea.left;
                        const chartHeight = chartArea.bottom - chartArea.top;
                        const scaleFactor = Math.min(chartWidth / 800, chartHeight / 600, 1);
                        const scaleFactorClamped = Math.max(0.5, Math.min(1.2, scaleFactor));

                        const logoSize = 38 * scaleFactorClamped;
                        const rightOffset = -20 * scaleFactorClamped;
                        const bottomOffset = 20 * scaleFactorClamped;
                        const urlPadding = 4 * scaleFactorClamped;
                        const fontSize = Math.max(9, 11 * scaleFactorClamped);

                        const logoX = chartArea.right - rightOffset;
                        const logoY = chartArea.bottom - bottomOffset - logoSize;

                        let logoWidth = logoSize;
                        let logoHeight = logoSize;

                        if (isoftLogoImage && isoftLogoImage.complete && isoftLogoImage.naturalWidth > 0) {
                            ctx.save();
                            const aspectRatio = isoftLogoImage.naturalWidth / isoftLogoImage.naturalHeight;
                            logoHeight = logoSize;
                            logoWidth = logoHeight * aspectRatio;
                            
                            const logoDrawX = logoX - logoWidth;
                            ctx.drawImage(isoftLogoImage, logoDrawX, logoY, logoWidth, logoHeight);
                            ctx.restore();
                        } else {
                            if (!isoftLogoImage || !isoftLogoImage.complete) {
                                preloadIsoftLogo();
                                setTimeout(() => {
                                    if (chart) chart.update('none');
                                }, 100);
                            }
                        }
                        
                        ctx.save();
                        ctx.font = `${fontSize}px Inter, sans-serif`;
                        ctx.fillStyle = '#2563eb';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'bottom';
                        
                        const urlText = 'https://isoft.cnu.ac.kr/';
                        const urlY = logoY + logoHeight + urlPadding + (12 * scaleFactorClamped);
                        ctx.fillText(urlText, logoX, urlY);
                        ctx.restore();
                    }
                }]
            };

            bestPerformanceChart = new Chart(ctx, chartConfig);
            bestPerformanceChart.chartData = data; // μ°¨νΈμ— λ°μ΄ν„° μ €μ¥
        }

        // μ°¨νΈ λ‹¤μ΄λ΅λ“
        function downloadChart(chartId, filename) {
            let chart;
            if (chartId === 'baselineChart') {
                chart = baselineChart;
            } else if (chartId === 'performanceChart') {
                chart = performanceChart;
            } else if (chartId === 'bestPerformanceChart') {
                chart = bestPerformanceChart;
            } else if (chartId === 'latencyPerformanceChart') {
                chart = latencyPerformanceChart;
            } else if (chartId.startsWith('reasoningChart_')) {
                // λ¨λ‹¬λ¦¬ν‹°λ³„ reasoning μ°¨νΈ
                const modality = chartId.replace('reasoningChart_', '').replace('Plus', '+');
                chart = window[`reasoningChart_${modality.replace('+', 'Plus')}`];
            }

            if (!chart) return;

            const url = chart.toBase64Image('image/png', 1);
            const link = document.createElement('a');
            link.download = `cast_leaderboard_${filename}_${new Date().toISOString().split('T')[0].replace(/-/g, '')}.png`;
            link.href = url;
            link.click();
        }

        // TSV νμΌ λ΅λ“
        function loadTSVFile() {
            const fileInput = document.getElementById('tsvFileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('νμΌμ„ μ„ νƒν•΄μ£Όμ„Έμ”.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    rawData = e.target.result;
                    parsedData = parseTSV(rawData);
                    document.getElementById('fileStatus').textContent = `β“ ${file.name} λ΅λ“ μ™„λ£`;
                    updateBaselineSection();
                    updatePerformanceSection();
                    updateReasoningSection();
                } catch (error) {
                    document.getElementById('fileStatus').textContent = `β— μ¤λ¥: ${error.message}`;
                    console.error('TSV νμ‹± μ¤λ¥:', error);
                }
            };
            reader.readAsText(file);
        }

        // ν•„ν„° λ³€κ²½ μ΄λ²¤νΈ λ¦¬μ¤λ„
        document.getElementById('languageFilter').addEventListener('change', updatePerformanceSection);
        document.getElementById('modalityFilter').addEventListener('change', updatePerformanceSection);
        document.getElementById('categoryFilter').addEventListener('change', updatePerformanceSection);

        // μ΄κΈ° λ΅λ“
        window.addEventListener('DOMContentLoaded', function() {
            // μ΄κΈ° μ–Έμ–΄ μ„¤μ • (μμ–΄)
            setLanguage('en');

            // Input Language ν•„ν„°λ¥Ό KoreanμΌλ΅ μ„¤μ • (μ΄κΈ° μ„¤μ •)
            const languageFilter = document.getElementById('languageFilter');
            if (languageFilter) {
                languageFilter.value = 'Korean';
            }

            // Vercel λ°°ν¬ ν™κ²½μ—μ„λ„ μ‘λ™ν•λ„λ΅ κ²½λ΅ μ²λ¦¬
            const defaultTSVPath = 'data/2026_math_odd.tsv';
            const categoryTSVPath = 'sample/ablation_by_prob_area.tsv';
            const latencyTSVPath = 'sample/ablation_table_latency.tsv';
            
            // κΈ°λ³Έ λ°μ΄ν„°, μΉ΄ν…κ³ λ¦¬ λ°μ΄ν„°, latency λ°μ΄ν„°λ¥Ό λ³‘λ ¬λ΅ λ΅λ“
            Promise.all([
                fetch(defaultTSVPath).then(r => r.ok ? r.text() : Promise.reject(new Error(`HTTP ${r.status}`))),
                fetch(categoryTSVPath).then(r => r.ok ? r.text() : Promise.reject(new Error(`HTTP ${r.status}`))),
                fetch(latencyTSVPath).then(r => r.ok ? r.text() : Promise.reject(new Error(`HTTP ${r.status}`))).catch(e => {
                    console.warn('Latency νμΌ λ΅λ“ μ‹¤ν¨:', e);
                    return null; // latency νμΌμ΄ μ—†μ–΄λ„ κ³„μ† μ§„ν–‰
                })
            ])
                .then(([mainText, categoryText, latencyText]) => {
                    if (!mainText || mainText.trim().length === 0) {
                        throw new Error('λ©”μΈ νμΌμ΄ λΉ„μ–΄μμµλ‹λ‹¤.');
                    }
                    rawData = mainText;
                    parsedData = parseTSV(rawData);
                    console.log('parsedData λ΅λ“ μ™„λ£:', parsedData?.models?.length, 'models');
                    
                    if (categoryText && categoryText.trim().length > 0) {
                        try {
                            categoryData = parseCategoryTSV(categoryText);
                            console.log('categoryData λ΅λ“ μ™„λ£:', Object.keys(categoryData || {}).length, 'models');
                        } catch (e) {
                            console.error('μΉ΄ν…κ³ λ¦¬ λ°μ΄ν„° νμ‹± μ‹¤ν¨:', e);
                            console.error('μ—λ¬ μ¤νƒ:', e.stack);
                        }
                    } else {
                        console.warn('μΉ΄ν…κ³ λ¦¬ λ°μ΄ν„° νμΌμ΄ λΉ„μ–΄μκ±°λ‚ λ΅λ“λμ§€ μ•μ•μµλ‹λ‹¤.');
                    }
                    
                    if (latencyText && latencyText.trim().length > 0) {
                        try {
                            latencyData = parseLatencyTSV(latencyText);
                            console.log('latencyData λ΅λ“ μ™„λ£:', Object.keys(latencyData || {}).length, 'models');
                        } catch (e) {
                            console.error('Latency λ°μ΄ν„° νμ‹± μ‹¤ν¨:', e);
                            console.error('μ—λ¬ μ¤νƒ:', e.stack);
                        }
                    } else {
                        console.warn('Latency λ°μ΄ν„° νμΌμ΄ λΉ„μ–΄μκ±°λ‚ λ΅λ“λμ§€ μ•μ•μµλ‹λ‹¤.');
                    }
                    
                    document.getElementById('fileStatus').textContent = 'β“ κΈ°λ³Έ νμΌ λ΅λ“ μ™„λ£';
                    
                    // λ°μ΄ν„° λ΅λ“ ν›„ ν•„ν„°λ¥Ό ν™•μ‹¤ν KoreanμΌλ΅ μ„¤μ •
                    const langFilter = document.getElementById('languageFilter');
                    if (langFilter) {
                        langFilter.value = 'Korean';
                    }
                    
                    // μΉ΄ν…κ³ λ¦¬ μ •λ³΄ μ΄κΈ°ν™”
                    updateCategoryInfo();
                    
                    // λ¨λ“  μ„Ήμ… μ—…λ°μ΄νΈ (Korean ν•„ν„°λ΅)
                    updateBaselineSection();
                    updatePerformanceSection(); // μ΄ ν•¨μκ°€ languageFilter.valueλ¥Ό μ½μ–΄μ„ Korean λ°μ΄ν„°λ¥Ό ν‘μ‹
                    updateReasoningSection();
                    updateBestPerformanceSection();
                })
                .catch(error => {
                    const errorMsg = `κΈ°λ³Έ νμΌ λ΅λ“ μ‹¤ν¨: ${error.message}`;
                    document.getElementById('fileStatus').textContent = errorMsg;
                    console.error('κΈ°λ³Έ νμΌ λ΅λ“ μ‹¤ν¨:', error);
                    console.error('μ‹λ„ν• κ²½λ΅:', defaultTSVPath, categoryTSVPath, latencyTSVPath);
                    // μ‚¬μ©μμ—κ² λ” λ…ν™•ν• λ©”μ‹μ§€ ν‘μ‹
                    alert('λ°μ΄ν„° νμΌμ„ λ΅λ“ν•  μ μ—†μµλ‹λ‹¤. κ°λ°μ λ¨λ“μ—μ„ νμΌμ„ μ—…λ΅λ“ν•΄μ£Όμ„Έμ”.');
                });
        });
    </script>
</body>
</html>
